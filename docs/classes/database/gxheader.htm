<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Database Headers </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Database Headers</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Constants">Constants</A><BR>
<A HREF="#TypeDefinitions">Type Definitions</A><BR>
<A HREF="#Enumerations">Enumerations</A><BR>
<A HREF="#FileHeader">File Header</A><BR>
<A HREF="#BlockHeader">Block Header</A><BR>
<A HREF="#FileLockHeader">File Lock Header</A><BR>
<A HREF="#RecordLockHeader">Record Lock Header</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>Type definitions, constants, and data structures needed by the 32/64-bit database engine and network DB functions to create database files and device headers. </P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Constants">Constants</A></P>
</B></FONT><PRE><A NAME="BlockDataAttributes">// Constants for dynamic data attributes used by the first byte of the</A>
// block header Status member.
const __SBYTE__ <B>gxBadBlock</B>     = 'B'; // Bad Block
const __SBYTE__ <B>gxDeletedBlock</B> = 'D'; // Deleted Block 
const __SBYTE__ <B>gxNormalBlock</B>  = 'N'; // Normal Read/Write attribute 
const __SBYTE__ <B>gxRemovedBlock</B> = 'R'; // Removed Block

// This block was received from a remote device. Added in revision C
const __SBYTE__ <B>gxRemoteDeviceBlock</B> = 'V'; 

<A NAME="BlockControlCommands">// Constants for block control characters used by the second byte of the</A>
// block header Status member. Added in revision C to handle device
// control commands.
const __SBYTE__ <B>gxAddRemoteBlock</B>    = 'A'; // Add a remote block
const __SBYTE__ <B>gxChangeRemoteBlock</B> = 'C'; // Change a remote block
const __SBYTE__ <B>gxDeleteRemoteBlock</B> = 'D'; // Delete a remote block
const __SBYTE__ <B>gxRequestFailed</B>     = 'F'; // The client request failed
const __SBYTE__ <B>gxCloseConnection</B>   = 'L'; // Close Client/Server connection
const __SBYTE__ <B>gxKillServer</B>        = 'K'; // Shutdown Client/Server
const __SBYTE__ <B>gxRequestBlock</B>      = 'R'; // Requesting a block
const __SBYTE__ <B>gxSendBlock</B>         = 'S'; // Sending raw data block
const __SBYTE__ <B>gxAcknowledgeBlock</B>  = 'W'; // Acknowledge a data block

// Constants for file operations and stream position 
const int <B>gxMaxNameLength</B>     = 255;     // Max length of file names
const FAU <B>gxStartOfFile</B>       = (FAU)0;  // First byte in the file
const FAU <B>gxCurrAddress</B>       = (FAU)-1; // Indicates current location
const gxUINT32 <B>gxCheckWord</B>    = 0xfefe;  // Default synchronization word
const gxINT32 <B>gxFSListCorrupt</B> = (FAU)-1; // Free space list is corrupt</PRE>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="TypeDefinitions">Type Definitions</A></P>
</B></FONT><U><P>Type definitions common to all platforms</U>:<BR>
<B>__SBYTE__</B> - Type definition for 8-bit signed values.<BR>
<B>__UBYTE__</B> - Type definition for 8-bit unsigned values.<BR>
<B>__WORD__</B> - Type definition for native integer types.<BR>
<B>__UWORD__</B> - Type definition for native unsigned integer types.<BR>
<B>__LWORD__</B> - Type definition for native 32-bit signed integer types.<BR>
<B>__ULWORD__</B> - Type definition for native 32-bit unsigned integer types.<BR>
<B>__SWORD__</B> - Type definition for native 16-bit signed integer types.<BR>
<B>__USWORD__</B> - Type definition for native 16-bit unsigned integer types.<BR>
<B>__DPFLOAT__</B> - Type definition for native 64-bit double precision floating points types.</P>
<U><P>Platform/Compiler specific type definitions</U>:<BR>
<B>__LLWORD__</B> - Type definition for native 64-bit signed integer types.<BR>
<B>__ULLWORD__</B> - Type definition for native 64-bit unsigned integer types.</P>
<U><P>Type definitions used for file operations and stream position</U>:<BR>
<B>FAU</B> - File address unit physical file address type.<BR>
<B>gxStreamPos</B> - Stream position indicator.</P>
<U><P>Type definition used to represent CRC-32 checksum values</U>:<BR>
<B>gxChecksum</B> - CRC-32 checksum type.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Enumerations">Enumerations</A></P>
</B></FONT><P>Enumerated integer constants used by the database engine to control file access, I/O operations, and identify file lock types.</P>
<PRE>enum <A NAME="gxDatabaseAccessMode">gxDatabaseAccessMode</A> { // gxDatabase access/open mode enumeration
  <B>gxDBASE_READONLY</B>,   // Open file with read access only
  <B>gxDABSE_WRITEONLY</B>,  // Open file with write access only
  <B>gxDBASE_READWRITE</B>,  // Open file with read and write access
  <B>gxDBASE_CREATE</B>,     // Create the file if it does not exist
  <B>gxDBASE_NO_CREATE</B>,  // Do not create the file if it does not exist
  <B>gxDBASE_TRUNCATE</B>,   // Truncate the file  
  <B>gxDBASE_APPEND</B>,     // Append to the file
  <B>gxDBASE_SHARE</B>,      // Enable file sharing  (Platform specific)
  <B>gxDBASE_EXCLUSIVE</B>   // Disable file sharing (Platform specific)
};

enum <A NAME="gxDatabaseOperation">gxDatabaseOperation</A> { // gxDatabase I/O operation codes
  <B>gxDBASE_READ</B>,         // A read was performed
  <B>gxDBASE_WRITE</B>,        // A write operation was performed
  <B>gxDBASE_REWIND</B>,       // A rewind operation was performed
  <B>gxDBASE_NO_OPERATION</B>, // No operation was performed
  <B>gxDBASE_SEEK</B>          // A seek operation was preformed 
};

enum <A NAME="gxDatabaseSeekMode">gxDatabaseSeekMode</A> { // gxDatabase seek mode enumeration
  <B>gxDBASE_SEEK_BEG</B>, // Seek starting from the beginning of the file
  <B>gxDBASE_SEEK_CUR</B>, // Seek starting from the current location
  <B>gxDBASE_SEEK_END</B>  // Seek starting from the end of the file
};

enum <A NAME="gxDatabaseLockType">gxDatabaseLockType</A> { // gxDatabase file/record lock enumeration
  <B>gxDBASE_READLOCK</B>,
  <B>gxDBASE_WRITELOCK
</B>};

enum <A NAME="gxDatabaseReclaimMethod">gxDatabaseReclaimMethod</A> { // gxDatabase Block reclamation methods
  <B>gxDBASE_RECLAIM_NONE</B> = 0, // Do not reclaim deleted blocks
  <B>gxDBASE_RECLAIM_BESTFIT</B>,  // Use the best fit reclamation method
  <B>gxDBASE_RECLAIM_FIRSTFIT</B>  // Use the first fit reclamation method
};</PRE>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="FileHeader">Database File Header</A></P>
</B></FONT><P>The gxFileHeader data structure is used to store information needed by the allocation functions, a signature and version number. When a new file is created the database engine reserves enough space, starting at file address 0, for the database file header. The database file header is composed of six fields and will vary in length depending on whether 32-bit or 64-bit file offsets are used.</P>
<FONT COLOR="#008080"><PRE>struct gxFileHeader // Database file header information
{ 
  FAU gxd_fs_fptr;      // Address to first block of free heap space
  FAU gxd_eof;          // Address of byte after end of file
  FAU gxd_hs_fptr;      // Address of the start of the heap space
  FAU gxd_hb_fptr;      // Highest allocated block
  __SBYTE__ gxd_sig[gxSignatureSize]; // Signature used to ID a database file 
  FAU gxd_ver;          // Database library version number
};</PRE>
</FONT><B><U><P>Free space field</B></U>:<BR>
The "free space" pointer is used by the allocation function to reclaim deleted blocks. The number of deleted blocks is maintained in a non-contiguous list. Each block in the list points to the next block in the list starting at a specified address. The "free space" pointer is used to store the file address of the block where the list starts. In order to prevent database files from becoming extremely fragmented due to numerous deletions, blocks marked deleted or removed will be reused by the allocation function. The database engine's allocation function checks the "free space" field before allocating new blocks. If the "free space" field is not empty, the allocation function will walk through the free space list looking for a deleted or removed block of the size to be allocated. This includes the size of the block data plus the block header. One of two methods can be used to reclaim deleted or removed blocks, the best-fit method or the first-fit method. The best-fit method works by scanning the entire free sp
ace list until the best location to reuse a block is found. The first-fit method works by searching the free space list until the first block of the appropriate size is found. Both methods will reuse any unused portion of a reclaimed block. The unused portion is assigned a new block header (marked removed) and placed back on the free space list. <B>NOTE</B>: If the free space list becomes corrupt, the "free space" field will be marked corrupt by the <B>gxFSListCorrupt</B> integer constant and is no longer used.</P>
<B><U><P>End of file field</B></U>:<BR>
The "end of file" pointer is used to mark the end of the file and locate where the file can be extended during block allocation. When an existing file is opened the database engine will compare this field to the true end of file. If the values do not match, this pointer will be adjusted if possible. </P>
<B><U><P>Start of heap field</B></U>:<BR>
The "start of heap" pointer is used to store the address where the static storage area ends and the dynamic data area begins. The allocation of new blocks will always start at this address. The size of the static storage area is determined when the file is created. Any data stored in the static area will not be altered by the block allocation routines. </P>
<B><U><P>Highest block field</B></U>:<BR>
The "highest block" pointer is used to store the address of the highest allocated block. This ensures that the database engine will always know where the first and last blocks are located in the file. This pointer is also useful for building descending order linear navigation functions.</P>
<B><U><P>Signature field</B></U>:<BR>
The signature field is used to determine if the file is of the correct type when an existing file is opened. When a new 32-bit file is created the database engine writes the "GXDBASE" string to this field and reserves the eighth byte for revision letter changes. When a new 64-bit file is created the database engine writes the "GXDBASE64" string to this field and reserves the tenth byte for revision letter changes.</P>
<B><U><P>Version field</B></U>:<BR>
A version number is used to indicate that changes have been made to the database engine without affecting the file format. Version numbers are used to conditionally perform certain operations based on its numerical value. This will ensure backward compatibility with previous versions of the database engine.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="BlockHeader">Database Block Header</A></P>
</B></FONT><P>The gxBlockHeader data structure is used to mark the start of a block in the dynamic data area and is additionally used for block transfers between local and remote devices. Block headers can be broken down into two specific categories: database blocks and device blocks. Database block headers are composed of four fields and will vary in length depending on whether 32-bit or 64-bit file offsets are used.</P>
<U><P>Database Blocks</U>:<BR>
A database block header is stored with each block allocated by an application and is used by the database engine to keep track of blocks stored in the dynamic data area. Applications can also use database block header information to obtain file locations and status information. When new blocks are allocated the database engine writes the block header and then reserves enough space to store the number of bytes requested. The application is responsible for writing the actual data in the block starting at the address following the block header. </P>
<U><P>Device Blocks</U>:<BR>
Device block headers contain synchronization and control information. They are used to transfer blocks and to signal events between devices. When an application sends a block of raw data the header precedes the block and informs the receiver of the block size and the block status. After reception of a device header the receiver then waits for the block data and processes the data or signals/handles an event according to the status of the block. </P>
<FONT COLOR="#008080"><PRE>// Database/Device Block Header 
struct gxBlockHeader
{
  gxUINT32 block_check_word; // Block synchronization marker
  gxUINT32 block_length;     // Block length (object length + overhead)  
  gxUINT32 block_status;     // First byte  = status of the block's data 
                             // Second byte = block control commands
                             // Third byte  = reserved for future use
                             // Fourth byte = reserved for future use
  FAU block_nd_fptr;         // Pointer to next deleted block
};</PRE>
</FONT><B><U><P>Check word field</B></U>:<BR>
The "check word" field represents a 32-bit check word. Database blocks use this field for integrity checks and to maintain synchronization between the database engine and the application. Device blocks use this field to maintain synchronization between local and remote devices. The check word field to should always be set using the <B>gxCheckWord</B> integer constant. <B>NOTE</B>: If the check word value is changed, database files and device drivers will no longer be compatible with previous releases. </P>
<B><U><P>Length field</B></U>:<BR>
The "length" field stores the total length of the block. Block lengths include the size of the object plus the total size of the block overhead determined by the by the database revision letter and whether the block is a database block or a device block.</P>
<U><P>Database Block Lengths</U>:<BR>
Revision 0 database blocks account for the length of the object plus the size of the block header. Revision 'A' database blocks account for the length of the object plus the size of the block header and the size of the block's CRC checksum value. Revision 'C' database blocks account for the length of the object plus the size of the block header, record lock header, and the size of the block's CRC checksum value. The database engine uses this field to index the file block by block. The "check-word" field is used to ensure that the next block in sequence is a valid block. The length of the object or record can be calculated by subtracting the total size of the block overhead from the "length" field.</P>
<U><P>Device Block Lengths</U>:<BR>
Device blocks are used to send and receive blocks to and from various I/O devices. <B>NOTE</B>: All device blocks will only account for the length of the object. Device blocks used to send and receive control signals will only account for the length of the block header as no additional data will be sent or received other then the block header itself.</P>
<B><U><P>Status field</B></U>:<BR>
The "status" field stores the status of the dynamic data contained in the block. Only two bytes of the status field are used. The remaining two bytes of the status field are reserved for future use. </P>
<U><P>Database Block Status Information:</U><BR>
The status of a database block can be determined by one of three primary byte values stored in the first block of the status field: 'N' for normal (ASCII 78), 'D' for deleted (ASCII 68), or 'R' for removed (ASCII 82). The database engine uses a signed byte constant named gxNormalBlock to mark normal database blocks, gxDeletedBlock to mark deleted database blocks, and gxRemovedBlock to mark database removed blocks. A block marked 'N' for normal indicates that the database block is in use and cannot be reclaimed by the allocation function. A block marked 'D' for deleted means that the data in the block is still valid, but the block can be overwritten if needed. Marking deleted blocks 'N' for normal can restore deleted database blocks. A block marked 'R' for removed means that the data in the block has been removed and the block can be overwritten. Once a block is removed it can never be restored.</P>
<U><P>Device Block Status Information</U>:<BR>
The status of a device block can be determined by one of several byte values stored in the second block of the status field. <A HREF="#BlockControlCommands">Block control characters</A> were added in revision 'C' to handle device control commands. Device control commands allow blocks to be added, changed, removed, and requested by local and remote devices. Device control commands are also used to signal events between local and remote devices.</P>
<B><U><P>Next deleted block field</B></U>:<BR>
Database blocks use the "next deleted block" field to store a file address to the next deleted or removed block, only if this block has been deleted or removed. Device block headers ignore this field by default. The total number of deleted database blocks is maintained in a non-contiguous list. Each deleted or removed database block in the list points to the next deleted or removed database block in the list starting at the head of the list.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="FileLockHeader">File Lock Header</A></P>
</B></FONT><P>The file lock header is used in revision 'B' and higher to allow applications to lock the entire file during a multi-threaded/multi-machine read or write operations. The advisory file locking scheme includes a lock protect member required to protect the lock values during multiple file access. <B>NOTE</B>: The lock protect member is required in the platform independent file locking system because file lock headers operate independently of the I/O subsystem and are manipulated by the database engine in the same manner as database blocks.</P>
<FONT COLOR="#008080"><PRE>struct gxFileLockHeader
{
  // The lock protect is used to serialize access to the file lock
  // values. The locking scheme will allow a total of 2^32 or
  // 4,294,967,295 threads to read lock a file and single thread to
  // write lock a file.
  gxUINT32 file_lock_protect; // Serialize access to the file lock members
  gxUINT32 file_read_lock;    // Shared (or read-only) file lock 
  gxUINT32 file_write_lock;   // Exclusive (or write-only) file lock
};</PRE>
</FONT><P><HR></P>
<B><FONT SIZE=4><P><A NAME="RecordLockHeader">Record Lock Header</A></P>
</B></FONT><P>Record lock headers are used by an application in revision 'C' to lock a specific block during a multi-threaded/multi-machine read or write operation. The advisory record locking scheme includes a lock protect member required to protect the lock values during multiple file access. <B>NOTE</B>: The lock protect member is required in the platform independent node locking system because record lock headers operate independently of the I/O subsystem and are manipulated by the database engine in the same manner as database blocks.</P>
<FONT COLOR="#008080"><PRE>struct gxRecordLockHeader // Lock a contiguous set of bytes
{
  // The lock protect is used to serialize access to each record 
  // lock. The locking scheme will allow a total of 2^32 or
  // 4,294,967,295 threads to read lock a record and single thread to
  // write lock a record.
  gxUINT32 record_lock_protect; // Serialize access to the record lock
  gxUINT32 record_read_lock;    // Shared (or read-only) file lock 
  gxUINT32 record_write_lock;   // Exclusive (or write-only) file lock
};</PRE>
</FONT><P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

<!doctype html>
<!-- ******************************* -->
<!-- ******** Start of Page ******** -->
<!-- ******************************* -->
<!-- *********************************************************** -->
<!-- HTML Page -->
<!-- Designed For: FireFox, Chrome, Safari -->
<!-- Published By: DataReel Software Development -->
<!-- Content Last Modified: 01/15/2024 -->
<!-- File Creation Date: 01/15/2024 20:43:41 EST -->
<!-- *** -->
<!-- Package version: 12.3.10 -->
<!-- *** -->
<!-- Copyright (c) 1999-2024 DataReel Software Development -->
<!-- *********************************************************** -->
<!-- *********** HTML Page Description and Details ************* -->
<!-- *********************************************************** -->
<!-- *** -->
<!-- START OF LICENSING AND DISCLAIMER AGREEMENT -->
<!-- *** -->
<!-- This HTML page and its derivatives are copyright (c) 1999-2024, by -->
<!-- DataReel Software Development. This HTML page and any derivative Web -->
<!-- objects are published on the Internet for public viewing only. -->
<!-- Reproduction of any HTML page and/or Web objects published on -->
<!-- this Website is prohibited unless authorized in writing by -->
<!-- DataReel Software Development or authorized reseller. Reproduction of any -->
<!-- third party code used to produce pages on this Website is subject to -->
<!-- the third party licensing and distribution agreement. -->
<!-- *** -->
<!-- THIS SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND. THE -->
<!-- ENTIRE RISK OF THE QUALITY AND PERFORMANCE OF THIS SOFTWARE IS WITH -->
<!-- YOU. SHOULD ANY ELEMENT OF THIS SOFTWARE PROVE DEFECTIVE, YOU WILL -->
<!-- ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION. -->
<!-- *** -->
<!-- *********************************************************** -->
<!-- *************** THIRD PARTY ACKNOWLEDGMENT **************** -->
<!-- *********************************************************** -->
<!-- *** -->
<!-- NONE -->
<!-- *** -->
<!-- END OF LICENSING AND DISCLAIMER AGREEMENT -->
<!-- *** -->
<!-- HTML Internet page -->
<!-- *********************************************************** -->
<!-- PAGE CONTENT STARTS BELOW -->

<html lang="en" data-bs-theme="auto">
  <head>
<!--HEADSTART-->
<!--HEADEND-->
    <title>gxbtree class</title>
    </head>
    <body>




<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">B-tree Class</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#NodeOrder">B-tree Node Order</A><BR>
<A HREF="#MemoryRequirements">Memory Requirements</A><BR>
<A HREF="#ConcurrentBtreeOperations">Concurrent B-tree Operations</A><BR>
<A HREF="#TuningParameters">Tuning Parameters</A><BR>
<A HREF="gxdbase.htm#ConditionalDirectives">Conditional Directives</A><BR>
<A HREF="gxheader.htm#Constants">Constants</A><BR>
<A HREF="#TypeDefinitions">Type Definitions</A><BR>
<A HREF="gxheader.htm#Enumerations">Enumerations</A><BR>
<A HREF="#Headers">Headers</A> <BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>A B-tree (Balance multi-way tree) is a special type of tree designed for fast disk-based insert, delete, and search operations. B-trees comprise a collection of multi-way nodes arranged in sort order. Multi-way nodes are used to store a left child pointer and multiple entry keys, with smaller keys on the left and larger keys on the right. Each entry key stores some type of data and right child pointer. The number of entry keys per node is determined by the node order. By definition B-trees are balanced, meaning that all nodes, except the root node, must be at least half full following an insertion or deletion. A single insertion can cause a number of splits all the way to the root node. The excessive node splitting that can occur following insertions and deletions complicate non-serialized concurrent operations.</P>
<P>The gxBtree class is a non-recursive disk-base B-tree used by various database applications for searching and sorting structured data and indexing associated objects or records stored in a data file. The gxBtree uses the 32/64-bit gxDatabase engine to perform all disk operations, supporting large files and proprietary file system interfaces. This is a non-recursive B-tree implementation designed to index any type of data regardless of the key type. It was originally designed to index multiple data types in read-only data files with 10M to 100M entries per index. Concurrent operations can be supported directly by serializing access to the entire tree or specific nodes during key insertions and key deletions. Additionally, concurrent operations can be supported using unbalanced deletions and file synchronization functions.</P>
<P>The gxBtree class uses three primary classes:</P>
<P><A HREF="dbasekey.htm">DatabaseKeyB</A> - Abstract base class used to define database key types and the methods by which database keys are sorted. The key type and comparison operators are defined in the derived class allowing the B-tree to index multiple data types.</P>
<P><A HREF="btnode.htm">BtreeNode</A> - B-tree node class used to manipulate a preset order of keys values in memory and on disk. B-tree nodes are stored on disk and manipulated in memory for fast disk-based operations. </P>
<P><A HREF="btstack.htm">BtreeStack</A> - Stack used in place of the processor stack to store node addresses during non-recursive insertions and deletions. Eliminating recursive insertions and deletions allow a single B-tree to grow extremely large and maintain stability.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="NodeOrder">B-tree Node Order</A></P>
</B></FONT><P>The B-tree node order determines the size of node and will affect the overall performance of the B-tree depending on the key type. The B-tree node memory requirements and disk read/write time per node can be calculated by multiplying the node order minus one by the entry key size. The total size of an entry key is the size of the database key type plus the size of the right child pointer (4 bytes for 32-bit offsets or 8 bytes for 64-bit offsets). The total overhead per node is equal to the key count (4 bytes) plus the size of the node's left child pointer (4 bytes for 32-bit offsets or 8 bytes for 64-bit offsets).</P>
<PRE>NodeOverhead = KeyCount + LeftChildPointer
NodeSize = (NodeOrder-1 * (KeySize + RightChildPointer)) + NodeOverhead</PRE>
<P>The gxBtree class manipulates nodes by loading each node into memory and writing nodes back to disk each time changes are made to the node. If the key size if relatively large then a big node order will increase the memory requirements for the node and the disk read/write times per node. Take for examples a B-tree with a key type consisting of a 64 byte fixed string with a node order of 7. A node order of 7 means that each node can have a maximum of 7 children and 6 entry keys. In this example all nodes other then the root node must have a minimum of 3 keys in order to meet the B-tree balancing requirements. Changing the node order will effect the node size and the height of the tree. A smaller node order will increase the height of the tree but will be more efficient during batch insertions because the of the smaller node size.</P>
<PRE>Node order 7 = 416 bytes per node (32-bit offsets)
Node order 128 = 8644 bytes per node (32-bit offsets)
Node order 256 = 17348 bytes per node (32-bit offsets)</PRE>
<P>As the size of the key type increases a smaller node order will lessen the memory requirements per node and decrease the disk read/write times but increase the highest of the tree. As you work with the B-tree class you might want to start with a node order of 7 (with larger data keys) and adjust the node order and possibly the key size according to batch insertion times. The key size is determined by the key class derived from the abstract <A HREF="dbasekey.htm">DatabaseKeyB</A> class. This implementation allows the B-tree to operate independently of actual key type and allows you to determine how the keys are searched and sorted. </P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="MemoryRequirements">Memory Requirements</A></P>
</B></FONT><P>The gxBtree memory utilization is preset based on the node order, file offset size, and key size. The gxBtree class is a non-recursive B-tree implementation designed to support multi-threaded applications. Some of the original designs included a recursive B-tree, a cached recursive B-tree and a cached non-recursive B-tree. Although recursion is very fast it proved to be unstable when the B-tree grew extremely large and resulted in data loss that was very difficult to troubleshoot. Disk caching would seem the best method to increase B-tree disk performance but the performance increase was negligible compared to the amount of overhead your application would have to absorb. Disk caching also complicates concurrent operations that are by nature extremely difficult to synchronize in any B-tree implementation. The end result was the non-recursive B-tree that does not use disk caching by default. Since disk caching requires the B-tree nodes to be stored in memory caching works best on systems with several megabytes of available memory. On low memory systems disk caching degrades performance severely if virtual memory or swap space is required. In non-cached implementations the amount of RAM used depends on the tree height and file offset size (4 bytes for 32-bit offsets or 8 bytes for 64-bit offsets). Since the B-tree is non-recursive it uses an explicit stack to store file offsets. The number of file offsets stored during any insert or delete operation depends on the height of tree.</P>
<P>Since the actual nodes are not stored in memory nodes are read from disk as the stack unwinds. Although this decreases B-tree performance during batch insertions it makes supporting multithreaded applications more achievable. Plus disk caching can degrade performance when large entry keys are used. The non-cached implementation allows you to insert millions of nodes using both high and low end hardware without any data loss and provides extremely fast search times and a multithreaded infrastructure. </P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="ConcurrentBtreeOperations">Concurrent B-tree Operations</A></P>
</B></FONT><P>Concurrent B-tree operations are extremely difficult to synchronize compared to an non-indexed data file. Locking individual records in an non-indexed data file is simple. The locking protocol allows a single thread to write lock a record and multiple threads to read lock a record. If a record is write locked then it cannot be read or modified until the thread holding the record releases it. If a record is read locked then up to 4 billion threads can read the record but the record cannot be modified until all the threads reading the record have released it. Applying a record locking protocol to a B-tree algorithm is far more complicated.</P>
<P>By definition a B-tree is blanched meaning all the nodes, except for the root node, must be at least half full following an insertion or deletion. A single insertion can result in several node splits and merges that propagate all the way to the root node, which may be re-grown. If you ease the balancing requires to support record locking the B-tree perform degrades to the point where is it unusable. The safest and most obvious solution is to serialize access to the entire B-tree during an insert or delete operation. A B-tree node-locking scheme involves finding the insertion or deletion point and calculating how many splits, merges, or rotations would occur and if any of those nodes are currently locked. If multiple nodes will be affected they could be write locked provided that another thread has not locked any of the nodes in the path of a balanced insertion or deletion. This may also result in every node in the B-tree being locked, which essentially locks the entire file. In the end this results in a tremendous amount of addition overhead and pointer manipulation. If you add node caching to the B-tree algorithm concurrent operations may not be obtainable without serializing access to the entire tree.</P>
<P>The non-recursive gxBtree implementation was originally designed to index very large data sets where the database was built by a single process and read by multiple threads. In order to optimize concurrent B-tree operations a lazy delete function and several built-in synchronization functions were added. The lazy delete function allows multiple threads to delete keys without balancing the tree and should only be used if the number of insertions heavily outweigh the number of deletions. The synchronization functions work by flushing any open disk buffers following an insert or delete and testing the B-tree header prior to performing an insert, delete, or find operation. The synchronization functions work best for multiple instances of single user applications. For example, an address book program where the user has launch two or three instances of the same application. To increase performance, speed wise, all the synchronization functions can be disabled.</P>
<P>A truly "thread safe" B-tree may ultimately be application dependent or bound to a specific data type. The gxBtree has an underlying infrastructure (file locking, node locking, lazy deletes, and synchronization functions) that allows it to support concurrent operations but it is not an out-of-the-box thread safe B-tree. The performance costs of serializing access to the entire B-tree can be offset by placing all threads in priority read and write queues. A more elaborate strategy would be to record lock the data file and file lock the indexing subsystem.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="TuningParameters">Tuning Parameters</A></P>
</B></FONT><P>You can increase the gxBtree's performance by modifying the 32/64-bit database engine and B-tree class. By default there are several flushing operations implemented to support multiple file access and reduce the possibility of data loss. </P>
<P>You can turn off the flushing operations and bit testing by changing the following default parameters to zero or setting the "flush" variable to zero before calling the function:</P>
<PRE>gxDatabaseError gxDatabase::Write(const void *buf, __ULWORD__ bytes, FAU file_address = gxCurrAddress, int flush = 1, int bit_test = 1);

int gxBtree::Insert(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1);
int gxBtree::Delete(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1);
int gxBtree::LazyDelete(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1);</PRE>
<P>You can also eliminate some additional overhead by changing revision level:</P>
<PRE>gxDatabaseError gxDatabase::Create(const char *fname, FAU static_size =(FAU_t)0, __SBYTE__ RevisionLetter = gxDatabaseRevisionLetter);</PRE>
<P>The version letter will determine the amount of overhead per database block. The 32/64-bit database engine allows you to mix <A HREF="gxdbase.htm#RevisionLevels">revision letters</A> as needed. This feature was added specifically for the B-tree algorithm because the data sets can be so large that even the slightest bit of overhead could increase the file size tremendously. Revision A, B, and C add features to maintain optimum data protection. Revision 0 offers the least amount of overhead per block. </P>
<P>The B-tree search functions can be optimized by disabling tree testing when a search function is called: </P>
<PRE>int gxBtree::Find(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int test_tree = 1)
int gxBtree::FindFirst(DatabaseKeyB &amp;key, int test_tree = 1);
int gxBtree::FindLast(DatabaseKeyB &amp;key, int test_tree = 1) 
int gxBtree::FindNext(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int test_tree = 1)
int gxBtree::FindPrev(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key,int test_tree = 1)</PRE>
<P>The "test_tree" variable defaults to true to ensure data integrity during multiple file access.</P>
<P><HR></P>
<P><!-- New Section --><A NAME="TypeDefinitions"><B><FONT SIZE=4>Type Definitions</A></B></FONT> </P>
<B><P>gxClassID - </B>Persistent class ID type</P>
<B><P>gxClassID_t - </B>Native class ID type </P>
<B><P>gxObjectID - </B>Persistent object ID type</P>
<B><P>gxObjectID_t - </B>Native object ID type</P>
<B><P>BtreeNodeOrder_t -</B> Type used for the B-tree node order</P>
<B><P>BtreeSize_t - </B>Type used to store entry key sizes</P>
<B><P>BtreeKeyCount_t - </B>Type used for the B-tree node key count</P>
<B><P>BtreeKeyLocation_t - </B>Type used for B-tree node key locations</P>
<P><A HREF="gxheader.htm#TypeDefinitions">Database engine type definitions</A></P>
<P><HR></P>
<P><A NAME="Headers"><!-- New Section --><B><FONT SIZE=4>B-tree Headers</A></B></FONT> </P>
<P>The B-tree header is a persistent data structure required to store tree parameters from one invocation of the program to the next. Each header is stored in a pre-allocated static storage area within the gxDatabase file. Multiple B-trees can be stored in a single file provided that a separate header exists for every tree.</P>
<FONT COLOR="#008080"><PRE>struct gxBtreeHeader
{ 
  BtreeNodeOrder_t node_order; // B-tree node order
  BtreeSize_t key_size;        // Database key size
  BtreeSize_t n_keys;          // Total number of entry keys
  BtreeSize_t n_nodes;         // Total number of nodes
  BtreeSize_t btree_height;    // Height of this B-tree
  FAU root;                    // B-tree root address  
  gxClassID class_id;          // Optional class ID for B-tree object keys
};</PRE>
</FONT><P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#gxBtree">gxBtree::gxBtree()</A><BR>
<A HREF="#gxBtreeDestructor">gxBtree::~gxBtree()</A><BR>
<A HREF="#BtreeHeader">gxBtree::BtreeHeader()</A><BR>
<A HREF="#BtreeHeight">gxBtree::BtreeHeight()</A><BR>
<A HREF="#ClassID">gxBtree::ClassID()</A><BR>
<A HREF="#Close">gxBtree::Close()</A><BR>
<A HREF="#CollapseRoot">gxBtree::CollapseRoot()</A><BR>
<A HREF="#Create">gxBtree::Create()</A><BR>
<A HREF="#DatabaseExceptionMessage">gxBtree::DatabaseExceptionMessage()</A><BR>
<A HREF="#Delete">gxBtree::Delete()</A><BR>
<A HREF="#DeleteDatabaseKey">gxBtree::DeleteDatabaseKey()</A><BR>
<A HREF="#Find">gxBtree::Find()</A><BR>
<A HREF="#FindFirst">gxBtree::FindFirst()</A><BR>
<A HREF="#FindLast">gxBtree::FindLast()</A><BR>
<A HREF="#FindNext">gxBtree::FindNext()</A><BR>
<A HREF="#FindPrev">gxBtree::FindPrev()</A><BR>
<A HREF="#Flush">gxBtree::Flush()</A><BR>
<A HREF="#GetDatabaseError">gxBtree::GetDatabaseError()</A><BR>
<A HREF="#GrowNewRoot">gxBtree::GrowNewRoot()</A><BR>
<A HREF="#HeaderAddress">gxBtree::HeaderAddress()</A><BR>
<A HREF="#HeaderInSync">gxBtree::HeaderInSync()</A><BR>
<A HREF="#InitBtree">gxBtree::InitBtree()</A><BR>
<A HREF="#Insert">gxBtree::Insert()</A><BR>
<A HREF="#InsertBalance">gxBtree::InsertBalance()</A><BR>
<A HREF="#InsertDatabaseKey">gxBtree::InsertDatabaseKey()</A><BR>
<A HREF="#InsertLeftRotation">gxBtree::InsertLeftRotation()</A><BR>
<A HREF="#InsertRightRotation">gxBtree::InsertRightRotation()</A><BR>
<A HREF="#IsEmpty">gxBtree::IsEmpty()</A><BR>
<A HREF="#KeySize">gxBtree::KeySize()</A><BR>
<A HREF="#LazyDelete">gxBtree::LazyDelete()</A><BR>
<A HREF="#LazyDeleteDatabaseKey">gxBtree::LazyDeleteDatabaseKey()</A><BR>
<A HREF="#Merge">gxBtree::Merge()</A><BR>
<A HREF="#NodeOrder">gxBtree::NodeOrder()</A><BR>
<A HREF="#NumKeys">gxBtree::NumKeys()</A><BR>
<A HREF="#NumNodes">gxBtree::NumNodes()</A><BR>
<A HREF="#Open">gxBtree::Open()</A><BR>
<A HREF="#ReInit">gxBtree::ReInit()</A><BR>
<A HREF="#ReadBtreeHeader">gxBtree::ReadBtreeHeader()</A><BR>
<A HREF="#ReadNode">gxBtree::ReadNode()</A><BR>
<A HREF="#Release">gxBtree::Release()</A><BR>
<A HREF="#ResetDatabaseError">gxBtree::ResetDatabaseError()</A><BR>
<A HREF="#Root">gxBtree::Root()</A><BR>
<A HREF="#SetDatabaseError">gxBtree::SetDatabaseError()</A><BR>
<A HREF="#TestTree">gxBtree::TestTree()</A><BR>
<A HREF="#TotalNodeSize">gxBtree::TotalNodeSize()</A><BR>
<A HREF="#WriteBtreeHeader">gxBtree::WriteBtreeHeader()</A><BR>
<A HREF="#WriteNode">gxBtree::WriteNode()</A><BR>
<A HREF="#gxDatabasePtr">gxBtree::gxDatabasePtr()</A></P>
<B><FONT COLOR="#000080"><P><A NAME="gxBtree">gxBtree::gxBtree(DatabaseKeyB &amp;key_type, BtreeNodeOrder_t order,gxClassID cid = (gxClassID_t)</A>-1)</B></FONT>&nbsp;- Class constructor used to set the database entry key type and node order. The class ID is an optional parameter used by applications that require unique class IDs when indexing associated objects.</P>
<B><FONT COLOR="#000080"><P><A NAME="gxBtreeDestructor">virtual gxBtree::~gxBtree()</A></B></FONT>&nbsp;-&nbsp;Virtual class destructor responsible for closing the file and flushing any open disk buffers. </P>
<B><FONT COLOR="#000080"><P><A NAME="BtreeHeader">gxBtreeHeader *gxBtree::BtreeHeader()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a pointer to B-tree header.</P>
<B><FONT COLOR="#000080"><P><A NAME="BtreeHeight">BtreeSize_t gxBtree::BtreeHeight()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the height of the B-tree.</P>
<B><FONT COLOR="#000080"><P><A NAME="ClassID">gxClassID gxBtree::ClassID()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the class ID of this B-tree.</P>
<B><FONT COLOR="#000080"><P><A NAME="Close">gxDatabaseError gxBtree::Close()</A></B></FONT>&nbsp;-&nbsp;Public member function used to close the open B-tree file. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="CollapseRoot">gxDatabaseError gxBtree::CollapseRoot()</A></B></FONT>&nbsp;-&nbsp;Protected member function used to collapse the current root node and shorten the tree. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="CollapseRoot_overload_1">gxDatabaseError gxBtree::CollapseRoot(BtreeNode &amp;root_node)</A></B></FONT>&nbsp;-&nbsp;Protected member function used to collapse the specified root node after a read operation and shorten the tree. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="Create">gxDatabaseError gxBtree::Create(const char *fname, int num_trees = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to create a new B-tree file, specifying the number of trees this index will contain. <B>NOTE</B>: This create function only initialize the first tree header and will always connect the tree to the first tree header. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="DatabaseExceptionMessage">const char *gxBtree::DatabaseExceptionMessage()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a null terminated string, which can be used to log or print the last reported database engine exception. </P>
<B><FONT COLOR="#000080"><P><A NAME="Delete">int gxBtree::Delete(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to delete the specified key and balance the B-tree following the deletion. Returns true if successful or false if the key could not be deleted. By default all disk buffers will be flushed following a deletion to maintain synchronization during multiple file access.<B> NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class.</P>
<B><FONT COLOR="#000080"><P><A NAME="DeleteDatabaseKey">gxDatabaseError gxBtree::DeleteDatabaseKey(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-Protected non-recursive balanced B-tree delete function used to ensure that all nodes, with the exception of the root node, are at least half full following a deletion. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="Find">int gxBtree::Find(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int test_tree = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the specified key in the B-tree. Returns true if successful or false if the key could not be found. <B>NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindFirst">int gxBtree::FindFirst(DatabaseKeyB &amp;key, int test_tree = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the first key in the B-tree. If the "test_tree" variable is true a test is performed to ensure that the file data stays in sync during multiple file access. Returns true if successful or false if the key could not be found.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindLast">int gxBtree::FindLast(DatabaseKeyB &amp;key, int test_tree = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the last key in the B-tree. If the "test_tree" variable is true a test is performed to ensure that the file data stays in sync during multiple file access. Returns true if successful or false if the key could not be found.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindNext">int gxBtree::FindNext(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key,int test_tree = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the next key after the specified key, passing back the key in the "key" variable. If the "test_tree" variable is true a test is performed to ensure that the file data stays in sync during multiple file access. Returns true if successful or false if the key could not be found. <B>NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindPrev">int gxBtree::FindPrev(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key,int test_tree = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the previous key before the specified key, passing back the key in the "key" variable. If the "test_tree" variable is true a test is performed to ensure that the file data stays in sync during multiple file access. Returns true if successful or false if the key could not be found. <B>NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class.</P>
<B><FONT COLOR="#000080"><P><A NAME="Flush">gxDatabaseError gxBtree::Flush()</A></B></FONT>&nbsp;-&nbsp;Public member function used to write the B-tree header and flush any open disk buffers. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetDatabaseError">gxDatabaseError gxBtree::GetDatabaseError()</A></B></FONT>&nbsp;-&nbsp;Public member function the returns an error code representing the last reported database error.</P>
<B><FONT COLOR="#000080"><P><A NAME="GrowNewRoot">gxDatabaseError gxBtree::GrowNewRoot(DatabaseKeyB &amp;key)</A></B></FONT>&nbsp;-&nbsp;Protected member function used to grow a new root node. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="HeaderAddress">FAU gxBtree::HeaderAddress()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the file address of the B-tree header for this tree.</P>
<B><FONT COLOR="#000080"><P><A NAME="HeaderInSync">int gxBtree::HeaderInSync()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the in-memory copy of the B-tree header is in sync with the disk copy.</P>
<B><FONT COLOR="#000080"><P><A NAME="InitBtree">gxDatabaseError gxBtree::InitBtree(gxDatabase *fptr, int create, FAU header_address)</A></B></FONT>&nbsp;-&nbsp;Public member function used to connect the B-tree to the database engine and write a new B-tree header if the "create" variable is true. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="InitBtree_overload_1">gxDatabaseError gxBtree::InitBtree(int create, FAU header_address)</A></B></FONT>&nbsp;-&nbsp;Public member function used connect the B-tree to a header in the open database engine or write a new B-tree header if the "create" variable is true. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="Insert">int gxBtree::Insert(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert the specified key. By default all disk buffers will be flushed following an insertion to maintain synchronization during multiple file access.<B> NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class. Returns true if successful or false if the key could not be inserted.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertBalance">gxDatabaseError gxBtree::InsertBalance(BtreeNode &amp;parent_node, BtreeKeyLocation_t key_location, DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-&nbsp;Protected member function used to balance this parent's sibling node after performing a deletion. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertDatabaseKey">gxDatabaseError gxBtree::InsertDatabaseKey(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;- Protected non-recursive insertion function used to insert a key into the B-tree. Returns zero if successful or a non-zero value to indicate a failure. </P>
<B><FONT COLOR="#000080"><P><A NAME="InsertLeftRotation">gxDatabaseError gxBtree::InsertLeftRotation(BtreeNode &amp;parent_node, BtreeKeyLocation_t key_location,DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-&nbsp;Protected member function used by the gxBtree::InsertBalance() function to perform a left rotation. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertRightRotation">gxDatabaseError gxBtree::InsertRightRotation(BtreeNode &amp;parent_node, BtreeKeyLocation_t key_location,DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-&nbsp;Protected member function used by the gxBtree::InsertBalance() function to perform a right rotation. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="IsEmpty">int gxBtree::IsEmpty()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the B-tree is empty.</P>
<B><FONT COLOR="#000080"><P><A NAME="KeySize">BtreeSize_t gxBtree::KeySize()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the current key size.</P>
<B><FONT COLOR="#000080"><P><A NAME="LazyDelete">int gxBtree::LazyDelete(DatabaseKeyB &amp;key, DatabaseKeyB &amp;compare_key, int flush = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to delete the specified key without balancing the tree following the deletion. Returns true if successful or false if the key could not be deleted. By default all disk buffers will be flushed following a deletion to maintain synchronization during multiple file access.<B> NOTE</B>: The "DatabaseKeyB&amp; compare_key" is a type cast from the derived key class back to a DatabaseKeyB base type and is required to perform comparisons because the comparison operators are not defined in the DatabaseKeyB base class.</P>
<B><FONT COLOR="#000080"><P><A NAME="LazyDeleteDatabaseKey">gxDatabaseError gxBtree::LazyDeleteDatabaseKey(DatabaseKeyB &amp;key,DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-&nbsp;Protected lazy (unbalanced) deletion method implemented specifically to support concurrent database operations that are effected by the excessive node splitting and merging that occurs during tree rotations. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="Merge">gxDatabaseError gxBtree::Merge(BtreeNode &amp;parent_node, BtreeKeyLocation_t key_location,DatabaseKeyB &amp;compare_key)</A></B></FONT>&nbsp;-&nbsp;Protected member function used by the gxBtree::InsertBalance() function to merge the parents left and right siblings and remove the right sibling. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P>BtreeNodeOrder_t gxBtree::NodeOrder()</B></FONT>&nbsp;-&nbsp;Public member function that returns the node order for this B-tree</P>
<B><FONT COLOR="#000080"><P><A NAME="NumKeys">BtreeSize_t gxBtree::NumKeys()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the total number entry keys stored in this B-tree.</P>
<B><FONT COLOR="#000080"><P><A NAME="NumNodes">BtreeSize_t gxBtree::NumNodes()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the total number of B-tree nodes.</P>
<B><FONT COLOR="#000080"><P><A NAME="Open">gxDatabaseError gxBtree::Open(const char *fname, gxDatabaseAccessMode mode = gxDBASE_READWRITE)</A></B></FONT>&nbsp;-&nbsp;Public member function used to open an existing B-tree file. Returns zero if successful or a non-zero value to indicate a failure. <B>NOTE</B>: This function assumes that there is only one B-tree in this file.</P>
<B><FONT COLOR="#000080"><P><A NAME="Open_overload_1">gxDatabaseError gxBtree::Open(const char *fname, FAU header_address,gxDatabaseAccessMode mode = gxDBASE_READWRITE)</A></B></FONT>&nbsp;-&nbsp;Public member function used to open an existing B-tree file, specifying the file address of the B-tree header. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReInit">gxDatabaseError gxBtree::ReInit(int flush = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function used to reconnect the B-tree header to ensure that the file data stays in sync during multiple file access and multiple instances of the same application. If the "flush" variable is true, the file buffers will be flushed to disk before reconnecting the B-tree. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReInit_overload_1">gxDatabaseError gxBtree::ReInit(FAU header_address, int flush = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function used to reconnect the B-tree to a new tree header. If the "flush" variable is true, the file buffers will be flushed to disk before reconnecting the B-tree. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReadBtreeHeader">gxDatabaseError gxBtree::ReadBtreeHeader()</A></B></FONT>&nbsp;-&nbsp;Public member function used to Read the B-tree header from disk. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReadNode">gxDatabaseError gxBtree::ReadNode(BtreeNode &amp;node, FAUnode_address = gxCurrAddress)</A></B></FONT>&nbsp;-&nbsp;Public member function used to read a B-tree node from the specified file address. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="Release">void gxBtree::Release()</A></B></FONT>&nbsp;-&nbsp;Public member function used to reset the database file pointer to zero without closing the file or performing any other action. <B>NOTE</B>: This function is used to reset the file pointer when more then one object is referencing this file pointer and the file has been closed or the pointer has been deleted. You can also use the a Release() class to signal that this object is finished with the file and can be deleted without affecting other objects currently using this file. </P>
<B><FONT COLOR="#000080"><P><A NAME="ResetDatabaseError">gxDatabaseError gxBtree::ResetDatabaseError()</A></B></FONT>&nbsp;-&nbsp;Public member function Public member function used to reset the last reported database engine error.</P>
<B><FONT COLOR="#000080"><P><A NAME="Root">FAU gxBtree::Root()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the file address of this B-tree's root node.</P>
<B><FONT COLOR="#000080"><P><A NAME="SetDatabaseError">gxDatabaseError gxBtree::SetDatabaseError(gxDatabaseError err)</A></B></FONT>&nbsp;-&nbsp;Public member function used to set the last reported database engine error. This function is used to inform the database engine of a fatal error condition. Redundantly returns the "err" value to allow this function to be used as a return value.</P>
<B><FONT COLOR="#000080"><P><A NAME="TestTree">int gxBtree::TestTree(int reinit = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to ensure that the file data stays in sync during multiple file access. If the "reinit" variable is true this function will reconnect the B-tree header. Returns zero if no errors were encountered or an integer value corresponding to one of the following values:</P>
<P>1 = Node order error <BR>
2 = Key size error <BR>
3 = Number of keys error<BR>
4 = Number of nodes error<BR>
5 = B-tree height error<BR>
6 = B-tree root address error<BR>
7 = B-tree class ID error<BR>
8 = Error reading the B-tree header</P>
<B><FONT COLOR="#000080"><P><A NAME="TotalNodeSize">size_t gxBtree::TotalNodeSize()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the total size of a single Btree node, including overhead.</P>
<B><FONT COLOR="#000080"><P><A NAME="WriteBtreeHeader">gxDatabaseError gxBtree::WriteBtreeHeader()</A></B></FONT>&nbsp;-&nbsp;Public member function used to write the B-tree header to disk. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="WriteNode">gxDatabaseError gxBtree::WriteNode(const BtreeNode &amp;node,FAU node_address = gxCurrAddress)</A></B></FONT>&nbsp;-&nbsp;Public member function used to write a B-tree node to the specified file address. Returns zero if successful or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="gxDatabasePtr">gxDatabase *gxBtree::gxDatabasePtr()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a pointer to the database engine.</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>


  </body>
</html>

<!-- PAGE CONTENT ENDS ABOVE -->
<!-- *********************************************************** -->
<!-- ******************************* -->
<!-- ********* End of Page ********* -->
<!-- ******************************* -->

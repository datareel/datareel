<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Thread Class </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<H1 ALIGN="CENTER">Thread Class</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Directives">Conditional Directives</A><BR>
<A HREF="#Typedefs">Type Definitions</A><BR>
<A HREF="#Enum">Enumerations</A><BR>
<A HREF="#Derived">Derived Class Interface</A><BR>
<A HREF="#Functions">Thread Functions</A><BR>
<A HREF="#Pool">Pool Functions</A><BR>
<A HREF="#Timer">Timer Functions</A></P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Overview">Overview</A></B></FONT> </P>
<P>The gxThread class is an abstract base class used to create platform independent multi-threaded applications. Its object-oriented design utilizes the multiple inheritance features of C++ to allow new or existing classes to directly integrate threading without sacrificing functionality. A derived class must define its own entry function for the operation that will run concurrently. Optionally a derived class can define an exit routine and a cleanup handler to perform any additional operations needed to free thread resources following an exit or cancel call. Refer to the <A HREF="tdiagram.htm">gxThread Model</A> block diagram for an illustration of the base/derived class relationship. </P>
<P>When a new thread is created a <A HREF="gthreadt.htm">gxThread_t</A> object is constructed and will hold a complete set of thread variables that will be available to the derived class through a gxThread_t pointer. Once a thread is created gxThread_t objects can be operated on independently of the base/derived class relationship. The gives the application the ability to control threads generated by any number of classes within the application. Additionally applications can use the built-in thread pool features of the gxThread class to group related and unrelated threads within a process together.</P>
<P>Applications built using the gxThread library should focus on the following modules:</P>
<P>thrtype.h - Type definitions used throughout the library <BR>
gxthread.h - Abstract gxThread base class<BR>
gthreadt.h - gxThread_t thread variable class<BR>
gxmutex.h - Mutal exclusion synchronization class <BR>
gxcond.h - Conditional variable synchronization class <BR>
gxsema.h - Semaphore synchronization class</P>
<P>All the other low-level wrappers are transparent to the application and are not intended for direct use.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Directives">Conditional Directives</A></P>
</B></FONT><P>In order to achieve cross-platform interoperability conditional directives are used by the low-level thread API wrapper classes to identify the correct thread API call for the each specific platform. The correct directive for your specific platform must be defined using the "-D" compiler option or from within your IDE. The following is a complete listing of all the conditional directives used in the gxThread library:</P>
<U><P>Windows 95/98/NT/2000 Directives</U>:</P>
<B><P>__WIN32__</B> WIN32 directive for Windows 95/98/NT/2000 applications.</P>
<B><P>__HAS__BEGINTHREADEX__ </B>Create thread using the _beginthreadex() C RTL call.</P>
<U><P>UNIX Directives</U>:</P>
<B><P>__UNIX__ </B>Generic UNIX directive. <B>NOTE</B>: This directive must be defined for all UNIX systems.</P>
<B><P>__POSIX__ </B>Define for applications using any version of POSIX threads.</P>
<B><P>__HPUX10__ </B>Define for all HPUX 10.20 applications.</P>
<B><P>__SOLARIS__ </B>Solaris directive. Must be defined for Solaris or POSIX threads.</P>
<B><P>__LINUX__ </B>Linux directive. Must be defined for Linux or POSIX threads.</P>
<U><P>Conditional Directives Reserved For Future Use In The gxThread Library</U>:</P>
<B><P>__MSVC__ </B>Microsoft Visual C++ 4.2 and higher compiler specifics.</P>
<B><P>__BCC32__</B> Borland BCC 4.0 and higher compiler specifics.</P>
<B><P>__MFC__ </B>MFC directive for Windows 95/98/NT MFC applications.</P>
<B><P>__HPUX__ </B>HPUX directive defined for all versions of HPUX.</P>
<B><P>__HPUX11__ </B>Define for all HPUX 11.0 and higher applications.</P>
<B><P>__LINUX_THREADS__</B> Define for applications using Linux threads.</P>
<B><P>__SOLARIS_THREADS__</B> Define for applications using Solaris threads.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Typedefs">Type Definitions</A></P>
</B></FONT><P>The following type definitions are used in the gxThread library to correctly identify and type cast thread variables between the various platforms. The gxThread types should always be used in place of the native types to ensure that the correct data type is used.</P>
<B><P>gxThreadID</B> - Type used to define the platform specific thread ID or HANDLE.</P>
<B><P>gxStackSizeType</B> - Define the integer type used to specify a stack size.</P>
<B><P>gxThreadExitCode </B>- Defines the integer type used to hold a thread's exit code.</P>
<B><P>gxThreadKey -</B> Type used to define the platform specific key type used for thread-specific values</P>
<B><P>gxThreadAttribute -</B> Type used to define the platform specific thread attribute structure.</P>
<B><P>gxThreadObjectID - </B>Defines the integer type used for a thread's object ID</P>
<B><P>gxThreadClassID - </B>Defines the integer type used for a thread's for class ID</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Enum">Enumerations</A></P>
</B></FONT><P>The following enumerations are used define integer constants used throughout the gxThread library.</P>
<PRE>enum <A NAME="gxThreadState"><B>gxThreadState</A></B> {        // Thread state enumeration
<B>gxTHREAD_STATE_INVALID</B> = 0, // The current state of this thread is unknown
<B>gxTHREAD_STATE_CANCELED</B>,    // Thread has been canceled
<B>gxTHREAD_STATE_EXITED</B>,      // Thread has exited
<B>gxTHREAD_STATE_NEW</B>,         // Newly created thread
<B>gxTHREAD_STATE_RUNNING</B>,     // Thread is currently running
<B>gxTHREAD_STATE_SUSPENDED</B>,   // Thread has been suspended
<B>gxTHREAD_STATE_WAITING</B>      // Execution is blocked waiting for a signal 
};

enum <A NAME="gxThreadPriority"><B>gxThreadPriority</A></B> {        // Thread priority enumeration
<B>gxTHREAD_PRIORITY_INVALID</B> = 0, // The priority of this thread is invalid
<B>gxTHREAD_PRIORITY_LOW</B>,         // Move to the bottom of the priority chain
<B>gxTHREAD_PRIORITY_NORMAL</B>,      // Add to the priority chain (default)
<B>gxTHREAD_PRIORITY_HIGH</B>         // Move to the top of the priority chain
};

enum <A NAME="gxThreadPriorityClass"><B>gxThreadPriorityClass</A></B> {         // Thread scheduling policies
<B>gxTHREAD_PRIORITY_CLASS_INVALID</B> = 0, // The priority class is invalid
&nbsp;
// POSIX scheduling policies. NOTE: The WIN32 scheduling policy is 
// determined by the priority class of its process. None of these
// policies have any effect under WIN32. 
<B>gxTHREAD_PRIORITY_CLASS_OTHER</B>, // Another scheduling policy (default policy)
<B>gxTHREAD_PRIORITY_CLASS_FIFO</B>,  // First in-first out (FIFO) scheduling policy
<B>gxTHREAD_PRIORITY_CLASS_RR</B>     // Round robin scheduling policy
};

enum <A NAME="gxThreadError"><B>gxThreadError</A></B> {     // Thread error code enumeration
<B>gxTHREAD_NO_ERROR</B> = 0,   // No errors reported
<B>gxTHREAD_INVALID_CODE</B>,   // Invalid error code
<B>gxTHREAD_CANCEL_ERROR</B>,   // Error canceling thread
<B>gxTHREAD_CLOSE_ERROR</B>,    // Error closing thread
<B>gxTHREAD_CREATE_ERROR</B>,   // Error creating thread
<B>gxTHREAD_RUNNING_ERROR</B>,  // Thread is already running
<B>gxTHREAD_EXECUTE_ERROR</B>,  // Thread cannot be executed 
<B>gxTHREAD_POLICY_ERROR</B>,   // Cannot retrieve thread scheduling policy
<B>gxTHREAD_PRIORITY_ERROR</B>, // Error setting the thread priority
<B>gxTHREAD_RESUME_ERROR</B>,   // Error resuming thread
<B>gxTHREAD_SCHED_ERROR</B>,    // Scheduling error
<B>gxTHREAD_SCOPE_ERROR</B>,    // Contention scope error
<B>gxTHREAD_STACK_ERROR</B>,    // Error setting the stack size
<B>gxTHREAD_STATE_ERROR</B>,    // Could not set the thread state
<B>gxTHREAD_SUSPEND_ERROR</B>   // Error suspending thread 
};

enum <A NAME="gxThreadType"><B>gxThreadType</A></B> {     // Thread type enumeration
<B>gxTHREAD_TYPE_DETACHED</B>, // System reclaims resources when thread terminates
<B>gxTHREAD_TYPE_JOINABLE  </B>// Thread exit code is available after termination
};

enum <A NAME="gxProcessType"><B>gxProcessType</A></B> {   // Process type enumeration
<B>gxPROCESS_PRIVATE</B> = 0, // Resources are available only to a single process
<B>gxPROCESS_SHARED</B> =  1  // Resources are available to multiple processes
};</PRE>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Derived">Derived Class Interface</A></P>
</B></FONT><P>The gxThread derived class interface consists of three functions:</P>
<B><FONT COLOR="#000080"><P>virtual void *gxThread::ThreadEntryRoutine(gxThread_t *thread) = 0 - </B></FONT>A derived class must override the gxThread::ThreadEntryRoutine() function, which is the thread's entry point of execution. The gxThread_t pointer is available to the derived class to allow the derived class to access thread variables.</P>
<B><FONT COLOR="#000080"><P>virtual void gxThread::ThreadExitRoutine(gxThread_t *thread) - </B></FONT>The gxThread::ThreadExitRoutine() function can be overridden by a derived class to perform any additional operations required before the thread exits. The gxThread_t pointer is available to the derived class to allow the derived class to access thread variables.</P>
<B><FONT COLOR="#000080"><P>virtual void gxThread::ThreadCleanupHandler(gxThread_t *thread) - </B></FONT>The gxThread::ThreadCleanupHandler should be overridden by a derived class if any cleanup operations need to be performed prior to thread cancellation. The gxThread_t pointer is available to the derived class to allow the derived class to access thread variables.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Functions">Thread Functions</A></P>
</B></FONT><P><A HREF="#CancelThread">gxThread::CancelThread</A> <BR>
<A HREF="#CloseThread">gxThread::CloseThread</A> <BR>
<A HREF="#ConstructThread">gxThread::ConstructThread</A> <BR>
<A HREF="#CreateThread">gxThread::CreateThread</A><BR>
<A HREF="#DestroyThread">gxThread::DestroyThread</A> <BR>
<A HREF="#ExitThread">gxThread::ExitThread</A> <BR>
<A HREF="#JoinThread">gxThread::JoinThread</A><BR>
<A HREF="#ResumeThread">gxThread::ResumeThread</A> <BR>
<A HREF="#SetThreadPriority">gxThread::SetThreadPriority</A> <BR>
<A HREF="#SuspendThread">gxThread::SuspendThread</A><BR>
<A HREF="#ThreadGetSpecific">gxThread::ThreadGetSpecific</A> <BR>
<A HREF="#ThreadKeyCreate">gxThread::ThreadKeyCreate</A> <BR>
<A HREF="#ThreadKeyDelete">gxThread::ThreadKeyDelete</A> <BR>
<A HREF="#ThreadSetSpecific">gxThread::ThreadSetSpecific</A> </P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="CancelThread">CancelThread</A>(gxThread_t *thread)</B></FONT> - Function used to cancel a thread during an operation when the thread is not allocating resources or accessing locked variables. Returns a non-zero value if the thread cannot be canceled. <B>NOTE</B>: The gxThread::ThreadCleanupHandler should be overridden by a derived class if any cleanup operations need to be performed prior to thread cancellation.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="CloseThread">CloseThread</A>(gxThread_t *thread)</B></FONT> - Close the thread's handle prior to destruction to indicate that the that storage space for the thread resources can be reclaimed. Returns a non-zero value if the thread cannot be closed.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::<A NAME="ConstructThread">ConstructThread</A>(gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - First of two overloads used to construct a new thread without executing it. Returns the newly constructed thread container or null if thread cannot be constructed.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::ConstructThread(void *parm, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - Second of two overloads used to construct a new thread without executing it. Returns the newly constructed thread container or null if thread cannot be constructed. This overload allows you to pass a parameter to the thread and optionally set the thread type and stack size.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::<A NAME="CreateThread">CreateThread</A>(gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - First of three overloads used to create and execute a new thread. <B>NOTE</B>: Any errors that occur will be recorded in gxThread_t::thread_error member and can be obtained by the application with a call to the gxThread_t::GetThreadError() function. Any errors reported by the thread's entry function can be obtained with a call to the gxThread_t::GetThreadExitCode() function. </P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::CreateThread(void *parm, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - Second of three overloads used to create and execute a new thread. <B>NOTE</B>: Any errors that occur will be recorded in gxThread_t::thread_error member and can be obtained by the application with a call to the gxThread_t::GetThreadError() function. Any errors reported by the thread's entry function can be obtained with a call to the gxThread_t::GetThreadExitCode() function. This overload allows you to pass a parameter to the thread and optionally set the thread type and stack size.</P>
<B><FONT COLOR="#000080"><P>int gxThread::CreateThread(gxThread_t *thread)</B></FONT> - Third of three overloads used to execute the specified thread, which was constructed by another entity. Returns a non-zero value if any errors occur.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="DestroyThread">DestroyThread</A>(gxThread_t *thread, int check_state = 1)</B></FONT> - Destroy a thread previously created with a call to the gxThread::CreateThread() function. If the "check_state" variable is true the thread's current state will be evaluated before the thread is destroyed. Returns a non-zero value if the thread cannot be destroyed.</P>
<B><FONT COLOR="#000080"><P>void * gxThread::<A NAME="ExitThread">ExitThread</A>(gxThread_t *thread, int exit_code)</B></FONT> - Exit function used by threads wishing to terminate explicitly in the middle of a task without terminating the whole process. Returns a pointer to the thread's exit code to allow this function to be used as a return value. <B>NOTE</B>: This function should only be called inside the thread entry routine, exit routine or cleanup handler.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="JoinThread">JoinThread</A>(gxThread_t *thread)</B></FONT> - This function will force a process to wait until the specified thread has finished execution before allowing the process to continue. Returns a non-zero value if any errors occur or the thread is not joinable.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="ResumeThread">ResumeThread</A>(gxThread_t *thread)</B></FONT> - Resume a thread that is currently suspended. Returns a non-zero value if any errors occur.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="SetThreadPriority">SetThreadPriority</A>(gxThread_t *thread)</B></FONT> - First of three overloads used to set or change the priority and scheduling policy of the a thread in accordance with gxThread_t::thread_priority and thread_class members. Returns a non-zero value if the priority or policy can not be changed. <B>NOTE</B>: Do to cross-platform issues the thread priority is no longer set when the thread is created. This function must be used to change a thread priority after it has been created.</P>
<B><FONT COLOR="#000080"><P>int gxThread::SetThreadPriority(gxThread_t *thread, gxThreadPriority prio)</B></FONT> - Second of three overloads used to set or change the priority of the specified thread. Returns a non-zero value if the priority can not be changed.</P>
<B><FONT COLOR="#000080"><P>int gxThread::SetThreadPriority(gxThread_t *thread, gxThreadPriority prio, gxThreadPriorityClass prio_class)</B></FONT> - Third of three overloads used to set or change the priority and scheduling policy of the specified thread. Returns a non-zero value if the priority or policy can not be changed. <B>NOTE</B>: The WIN32 scheduling policy is determined by the priority class of its process and will not be set here.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="SuspendThread">SuspendThread</A>(gxThread_t *thread)</B></FONT> - Suspend a thread that is currently running. Returns a non-zero value if any errors occur. <B>NOTE</B>: This function should only be called inside the thread entry routine, exit routine or cleanup handler.</P>
<B><FONT COLOR="#000080"><P>void * gxThread::<A NAME="ThreadGetSpecific">ThreadGetSpecific</A>(gxThreadKey &amp;key)</B></FONT> - Returns the value currently bound to the specified key for the calling thread. Returns a non-zero value if an error occurs.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="ThreadKeyCreate">ThreadKeyCreate</A>(gxThreadKey &amp;key)</B></FONT> - Creates a thread-specific data key. Returns a non-zero value if any errors occur.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="ThreadKeyDelete">ThreadKeyDelete</A>(gxThreadKey &amp;key)</B></FONT> - Releases a thread local storage key. <B>NOTE</B>: It is the responsibility of the application to free any allocated dynamic storage associated with this key prior to calling this function. Returns a non-zero value if any errors occur.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="ThreadSetSpecific">ThreadSetSpecific</A>(gxThreadKey &amp;key, const void *value)</B></FONT> - Stores a value in the calling thread's thread local storage slot for the specified thread. Returns a non-zero value if any errors occur.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Pool">Pool Functions</A></P>
</B></FONT><P><A HREF="#ConstructThreadInPool">gxThread::ConstructThread</A><BR>
<A HREF="#ConstructThreadPool">gxThread::ConstructThreadPool</A><BR>
<A HREF="#CreateThreadPool">gxThread::CreateThread</A> <BR>
<A HREF="#CreateThreadPool">gxThread::CreateThreadPool</A><BR>
<A HREF="#DestoryThreadPool">gxThread::DestoryThreadPool</A><BR>
<A HREF="#JoinThreadPool">gxThread::JoinThread</A><BR>
<A HREF="#RebuildThreadPool">gxThread::RebuildThreadPool</A> </P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::<A NAME="ConstructThreadInPool">ConstructThread</A>(thrPool *thread_pool, gxThreadPriority prio = gxTHREAD_PRIORITY_NORMAL, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - First of two overloads used to construct a new thread and throw it in the specified thread pool without executing it. Returns the newly constructed thread or null if thread cannot be constructed. <B>NOTE</B>: The thread priority will determine its priority in the thread queue.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::ConstructThread(thrPool *thread_pool, void *parm, gxThreadPriority prio = gxTHREAD_PRIORITY_NORMAL, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - Second of two overloads used to construct a new thread and throw it in the specified thread pool without executing it. Returns the newly constructed thread or null if thread cannot be constructed. <B>NOTE</B>: The thread priority will determine its priority in the thread queue. This overload allows you to pass a parameter to the thread when it is constructed.</P>
<P>&nbsp;<B><FONT COLOR="#000080">thrPool * gxThread::<A NAME="ConstructThreadPool">ConstructThreadPool</A>(unsigned pool_size)</B></FONT> - Construct a new thread pool with the specified number of nodes. <B>NOTE</B>: None of threads in the pool will be executed. Returns a pointer to the newly constructed thread pool or a null value if the pool could not be created.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::CreateThread(thrPool *thread_pool, gxThreadPriority prio = gxTHREAD_PRIORITY_NORMAL, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - First of two overloads used to create a new thread and throw it in the specified thread pool after executing it. Returns the newly constructed thread or null if thread cannot be constructed. <B>NOTE</B>: The thread priority will determine its priority in the thread queue.</P>
<B><FONT COLOR="#000080"><P>gxThread_t * gxThread::CreateThread(thrPool *thread_pool, void *parm, gxThreadPriority prio = gxTHREAD_PRIORITY_NORMAL, gxThreadType t = gxTHREAD_TYPE_JOINABLE, gxStackSizeType ssize = 0)</B></FONT> - Second of two overloads used to create a new thread and throw it in the specified thread pool after executing it. Returns the newly constructed thread or null if thread cannot be constructed. NOTE: The thread priority will determine its priority in the thread queue. This overload allows you to pass a parameter to the thread before it is executed.</P>
<B><FONT COLOR="#000080"><P>thrPool *gxThread::<A NAME="CreateThreadPool">CreateThreadPool</A>(unsigned pool_size, void *parm, gxThreadPriority prio, gxThreadType t, gxStackSizeType ssize)</B></FONT> - Create a new thread pool and execute each thread in the pool as it is created. Returns a pointer to the newly created thread pool or a null value if the pool could not be created.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="DestoryThreadPool">DestoryThreadPool</A>(thrPool *thread_pool, int check_state = 1)</B></FONT> - Destroy a previously created thread pool. If the "check_state" variable is true the current state of each thread will be checked before it is destroyed. If a thread cannot be canceled and the "check_state" variable is true, this function will return a non-zero value.</P>
<B><FONT COLOR="#000080"><P>int gxThread::<A NAME="JoinThreadPool">JoinThread</A>(thrPool *thread_pool)</B></FONT> - Make the process wait until all the threads in the specified pool have finished executing. Returns a non-zero value if the threads cannot be joined.</P>
<B><FONT COLOR="#000080"><P>void gxThread::<A NAME="RebuildThreadPool">RebuildThreadPool</A>(thrPool *thread_pool)</B></FONT> - Remove all the threads in the pool that have exited or have been canceled.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Timer">Timer Functions</A></P>
</FONT><FONT COLOR="#000080"><P>void gxThread::<A NAME="mSleep">mSleep</A>(int milliseconds)</B></FONT> - Suspends the execution of the current thread for a specified number of milliseconds.</P>
<B><FONT COLOR="#000080"><P>void gxThread::<A NAME="sSleep">sSleep</A>(int seconds)</B></FONT> - Suspends the execution of the current thread for a specified number of seconds.</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER">End Of Document</TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

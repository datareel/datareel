<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Memory Buffer </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Memory Buffer Class</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The MemoryBuffer is a general-purpose class is used to create and manipulate resizable memory buffers. The MemoryBuffer class guarantees that each object is unique by storing a unique copy of each buffer with each object. This ensures that MemoryBuffer objects can be safely copy constructed, assigned, resized, and deleted by multiple threads. <B>NOTE</B>: Multiple threads accessing shared memory segments must be handled by the application.</P>
<P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#MemoryBuffer">MemoryBuffer::MemoryBuffer()</A><BR>
<A HREF="#MemoryBufferDestructor">MemoryBuffer::~MemoryBuffer()</A><BR>
<A HREF="#Alloc">MemoryBuffer::Alloc()</A><BR>
<A HREF="#Cat">MemoryBuffer::Cat()</A><BR>
<A HREF="#Clear">MemoryBuffer::Clear()</A><BR>
<A HREF="#DeleteAt">MemoryBuffer::DeleteAt()</A><BR>
<A HREF="#Destroy">MemoryBuffer::Destroy()</A><BR>
<A HREF="#Find">MemoryBuffer::Find()</A><BR>
<A HREF="#FreeBytes">MemoryBuffer::FreeBytes()</A><BR>
<A HREF="#InsertAt">MemoryBuffer::InsertAt()</A><BR>
<A HREF="#Load">MemoryBuffer::Load()</A><BR>
<A HREF="#Realloc">MemoryBuffer::Realloc()</A><BR>
<A HREF="#ReplaceAt">MemoryBuffer::ReplaceAt()</A><BR>
<A HREF="#dlength">MemoryBuffer::dlength()</A><BR>
<A HREF="#is_null">MemoryBuffer::is_null()</A><BR>
<A HREF="#length">MemoryBuffer::length()</A><BR>
<A HREF="#m_buf">MemoryBuffer::m_buf()</A><BR>
<A HREF="#resize">MemoryBuffer::resize()</A><BR>
<A HREF="#OverloadedOperators">MemroyBuffer Overloaded Operators</A></P>
<B><FONT COLOR="#000080"><P><A NAME="MemoryBuffer">MemoryBuffer::MemoryBuffer()</A></B></FONT>&nbsp;-&nbsp;Default class constructor. </P>
<B><FONT COLOR="#000080"><P><A NAME="MemoryBuffer_overload_1">MemoryBuffer::MemoryBuffer(unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Class constructor used to allocate a specified number of bytes in memory for a buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="MemoryBuffer_overload_2">MemoryBuffer::MemoryBuffer(const void *buf, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Class constructor used to allocate a specified number of bytes for buffer "buf" and load the memory buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="MemoryBuffer_overload_3">MemoryBuffer::MemoryBuffer(const MemoryBuffer &amp;buf)</A></B></FONT>&nbsp;-&nbsp;Class copy constructor. This copy constructor does not use share semantics and guarantees that each copy will be unique.</P>
<B><FONT COLOR="#000080"><P><A NAME="MemoryBufferDestructor">MemoryBuffer::~MemoryBuffer()</A></B></FONT>&nbsp;-&nbsp;Class destructor responsible for freeing the memory allocated for this buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="Alloc">void *MemoryBuffer::Alloc(unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to allocate a specified number of bytes for this memory buffer. This function will try to re-use the current memory segment allocated for this buffer before re-allocating memory for the buffer. Returns a void pointer to the buffer or a null value if a memory allocation error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="Cat">void MemoryBuffer::Cat(const void *buf, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to concatenate a specified number of bytes from a memory location to the end of the object that invoked the call.</P>
<B><FONT COLOR="#000080"><P><A NAME="Cat_overload_1">void MemoryBuffer::Cat(unsigned char byte)</A></B></FONT>&nbsp;-&nbsp;Public member function used to concatenate a single byte to the end of the object that invoked the call.</P>
<B><FONT COLOR="#000080"><P><A NAME="Cat_overload_2">void MemoryBuffer::Cat(char byte)</A></B></FONT>&nbsp;-&nbsp;Public member function used to concatenate a single byte to the end of the object that invoked the call. </P>
<B><FONT COLOR="#000080"><P><A NAME="Clear">void MemoryBuffer::Clear()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear this buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="DeleteAt">unsigned MemoryBuffer::DeleteAt(unsigned position, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to delete a specified number of bytes, starting at the specified position. Returns the number of bytes deleted.</P>
<B><FONT COLOR="#000080"><P><A NAME="Destroy">void MemoryBuffer::Destroy()</A></B></FONT>&nbsp;-&nbsp;Public member function used to free the memory allocated for the buffer and reset the length variables.</P>
<B><FONT COLOR="#000080"><P><A NAME="Find">unsigned MemoryBuffer::Find(void *buf, unsigned offset = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the index of first occurrence of pattern "buf." Returns -1 if pattern not found.</P>
<B><FONT COLOR="#000080"><P><A NAME="Find_overload_1">unsigned MemoryBuffer::Find(void *buf, unsigned bytes, unsigned offset = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the index of first occurrence of pattern "buf." Returns -1 if pattern not found.</P>
<B><FONT COLOR="#000080"><P><A NAME="Find_overload_2">unsigned MemoryBuffer::Find(const MemoryBuffer &amp;buf, unsigned offset = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the index of first occurrence of pattern "buf." Returns -1 if pattern not found.</P>
<B><FONT COLOR="#000080"><P><A NAME="FreeBytes">void *MemoryBuffer::FreeBytes()</A></B></FONT>&nbsp;-&nbsp;Public member function used to free any unused bytes allocated for this buffer. Returns a pointer to the re-allocated memory buffer or a null value if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertAt">unsigned MemoryBuffer::InsertAt(unsigned position, const void *buf, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a specified number of bytes a the current position, keeping the current data intact. Returns the number of bytes inserted or zero if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertAt_overload_1">unsigned MemoryBuffer::InsertAt(unsigned position, const MemoryBuffer &amp;buf)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a specified number of bytes a the current position, keeping the current data intact. Returns the number of bytes inserted or zero if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="Load">int MemoryBuffer::Load(const void *buf, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to load this object with a unique copy of the specified buffer. Returns true if successful or false if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="Realloc">void *MemoryBuffer::Realloc(unsigned bytes, int keep = 1, int reuse = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to resize the logical length of the buffer. If the "keep" variable is true the old data will be copied into the new space. By default the old data will not be deleted. Returns a pointer to the buffer or a null value if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReplaceAt">unsigned MemoryBuffer::ReplaceAt(unsigned position, const void *buf, unsigned bytes)</A></B></FONT>&nbsp;-&nbsp;Public member function used to replace a specified number of bytes at the specified position. Returns the number of bytes replaced or zero if an error occurs. </P>
<B><FONT COLOR="#000080"><P><A NAME="ReplaceAt_overload_1">unsigned MemoryBuffer::ReplaceAt(unsigned position, const MemoryBuffer &amp;buf)</A></B></FONT>&nbsp;-&nbsp;Public member function used to replace a specified number of bytes at the specified position. Returns the number of bytes replaced or zero if an error occurs.</P>
<B><FONT COLOR="#000080"><P><A NAME="dlength">unsigned MemoryBuffer::dlength()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the dimensioned length of this buffer. The dimensioned length refers to the total number of bytes that have been allocated and the logical length refers to the actual length of the buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="is_null">int MemoryBuffer::is_null()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if this buffer is null.</P>
<B><FONT COLOR="#000080"><P><A NAME="length">unsigned MemoryBuffer::length()</A></B></FONT>&nbsp;-&nbsp; Public member function that returns the logical length of this buffer. The logical length refers to the actual length of the buffer and the dimensioned length refers to the total number of bytes that have been allocated for this buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="m_buf">unsigned char *MemoryBuffer::m_buf()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a pointer to the memory buffer.</P>
<B><FONT COLOR="#000080"><P><A NAME="resize">int MemoryBuffer::resize(unsigned bytes, int keep = 1)</A></B></FONT>&nbsp;-&nbsp;Public member function used to resize the logical length of the buffer. If the "keep" variable is true the old data will be copied into the new space. By default the old data will not be deleted. Returns true if successful or false if an error occurs.</P>
<B><U><P><A NAME="OverloadedOperators">Overloaded operators</A></B></U>:<BR>
<B><FONT COLOR="#000080">MemoryBuffer &amp;MemoryBuffer::operator=(const MemoryBuffer &amp;buf)</B></FONT>&nbsp;-&nbsp;Class assignment operator. This assignment operator does not use share semantics and guarantees that each copy will be unique.</P>
<B><FONT COLOR="#000080"><P>int MemoryBuffer::operator!() </FONT>- </B>Overloaded not operator that returns true if the buffer is null.</P>
<B><FONT COLOR="#000080"><P>operator MemoryBuffer::int () </FONT>- </B>Conversion function that returns true if the buffer is not null.</P>
<B><FONT COLOR="#000080"><P>unsigned char&amp; MemoryBuffer::operator[](unsigned i)</B></FONT>&nbsp;-&nbsp;Overloaded subscript operator used to ensure that an index is in range before subscripting this object's data. If the index is out of range the index value will be set to the logical length. </P>
<B><FONT COLOR="#000080"><P>void MemoryBuffer::operator+=(const MemoryBuffer &amp;buf)</B></FONT>&nbsp;-&nbsp;Overloaded member operator used to concatenate a memory buffer to the end of the object that invoked the call.</P>
<B><FONT COLOR="#000080"><P>void MemoryBuffer::operator+=(const unsigned char &amp;byte)</B></FONT>&nbsp;-&nbsp;Overloaded member operator used to concatenate a single byte to the end of the object that invoked the call.</P>
<B><FONT COLOR="#000080"><P>void MemoryBuffer::operator+=(const char &amp;byte)</B></FONT>&nbsp;-&nbsp;Overloaded member operator used to concatenate a single byte to the end of the object that invoked the call.</P>
<B><FONT COLOR="#000080"><P>friend MemoryBuffer operator+(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator used to add two MemoryBuffer objects together. </P>
<B><FONT COLOR="#000080"><P>friend int operator==(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operands are equal to each other. </P>
<B><FONT COLOR="#000080"><P>friend int operator!=(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operands are not equal to each other. </P>
<B><FONT COLOR="#000080"><P>friend int operator&gt;(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is greater then "b." </P>
<B><FONT COLOR="#000080"><P>friend int operator&gt;=(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is greater then or equal to "b." </P>
<B><FONT COLOR="#000080"><P>friend int operator&lt;(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is less then "b." </P>
<B><FONT COLOR="#000080"><P>friend int operator&lt;=(const MemoryBuffer &amp;a, const MemoryBuffer &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is less then or equal to "b."</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

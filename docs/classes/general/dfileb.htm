<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Disk File Base </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Disk File Base</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#ConditionalDirectives">Conditional Directives</A><BR>
<A HREF="#Constants">Constants</A><BR>
<A HREF="#TypeDefinitions">Type Definitions</A><BR>
<A HREF="#Enumerations">Enumerations</A><BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The disk file class is a general-purpose base class used to perform various file and directory functions.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="ConditionalDirectives">Conditional Directives</A></P>
</FONT><P>__DJGPP2721__</B> - Conditional directive required to compile with the DJGPP compiler.</P>
<B><P>__DOS__</B> - Conditional directive required to compile under DOS or WIN32 file systems.</P>
<B><P>__DOS_INCLUDES__</B> - Conditional directive required by 16-bit DOS compilers.</P>
<B><P>__MSVC_FILE_SHARING__</B> - Open the file in binary mode using MSVC file sharing.</P>
<B><P>__UNIX__</B> - Conditional directive required to compile under UNIX file systems. </P>
<B><P>__WIN32__</B> - Conditional directive required to compile under WIN32 file systems.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Constants">Constants</A></P>
</B></FONT><PRE>const unsigned <B>df_MAX_LINE_LENGTH</B> = 1024; // Maximum line length
const unsigned <B>df_MAX_NAME_LENGTH</B> = 255;  // Maximum length of a file name
const unsigned <B>df_MAX_DIR_LENGTH</B> = 1024;  // Maximum length of a directory name
const df_StreamPos <B>df_CurrPosition</B> = -1;  // Indicates current file position</PRE>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="TypeDefinitions">Type Definitions</A></P>
</FONT><P>df_StreamPos</B> - Type definition used to indicate the current stream position.</P>
<P><HR></P>
<B><FONT SIZE=4><P><A NAME="Enumerations">Enumerations</A></P>
</B></FONT><PRE>
<A NAME="ErrorCodeEnumeration">enum { // DiskFileB error codes</A>
    DiskFileB::<B>df_NO_ERROR</B> = 0,       // No errors reported
    DiskFileB::<B>df_INVALID_ERROR_CODE</B>, // Invalid file error code

    // File error exception codes
    DiskFileB::<B>df_CLOSE_ERROR</B>,  // Error closing the file
    DiskFileB::<B>df_COPY_ERROR</B>,   // Error copying file
    DiskFileB::<B>df_CREATE_ERROR</B>, // Could not create the file
    DiskFileB::<B>df_EOF_ERROR</B>,    // End of file error
    DiskFileB::<B>df_EXIST_ERROR</B>,  // The file does not exist
    DiskFileB::<B>df_FLUSH_ERROR</B>,  // Error flushing the disk buffers
    DiskFileB::<B>df_MODE_ERROR</B>,   // An invalid access/open mode specified
    DiskFileB::<B>df_OPEN_ERROR</B>,   // Could not open the file
    DiskFileB::<B>df_READ_ERROR</B>,   // An error occurred during a read operation
    DiskFileB::<B>df_REMOVE_ERROR</B>, // Could remove the specified file
    DiskFileB::<B>df_RENAME_ERROR</B>, // Could not rename the specified file
    DiskFileB::<B>df_REWIND_ERROR</B>, // Error rewinding the file
    DiskFileB::<B>df_SEEK_ERROR</B>,   // An error occurred during a seek operation
    DiskFileB::<B>df_WRITE_ERROR</B>,  // An error occurred during a write operation

    // Directory error exception codes
    DiskFileB::<B>df_CHDIR_ERROR</B>,  // Could not change directory
    DiskFileB::<B>df_MKDIR_ERROR</B>,  // Could not create directory
    DiskFileB::<B>df_RMDIR_ERROR</B>   // Could not remove directory
  };

  <A NAME="AccessModeEnumeration">enum { // DiskFileB access/open mode enumeration</A>
    DiskFileB::<B>df_READONLY</B>,   // Open file with read access only
    DiskFileB::<B>df_WRITEONLY</B>,  // Open file with write access only
    DiskFileB::<B>df_READWRITE</B>,  // Open file with read and write access
    DiskFileB::<B>df_CREATE</B>,     // Create the file if it does not exist
    DiskFileB::<B>df_NO_CREATE</B>,  // Do not create the file if it does not exist
    DiskFileB::<B>df_TRUNCATE</B>,   // Truncate the file  
    DiskFileB::<B>df_APPEND</B>,     // Append to the file
    DiskFileB::<B>df_SHARE</B>,      // Enable file sharing (DOS and WIN32 only)
    DiskFileB::<B>df_EXCLUSIVE</B>   // No file sharing (DOS and WIN32 only)
  };

  <A NAME="SeekModeEnumeration">enum { // DiskFileB seek modes</A>
    DiskFileB::<B>df_SEEK_BEG</B>, // Seek starting from the beginning of the file
    DiskFileB::<B>df_SEEK_CUR</B>, // Seek starting from the current location
    DiskFileB::<B>df_SEEK_END</B>  // Seek starting from the end of the file
  };

  <A NAME="IO_OperationEnumeration">enum { // DiskFileB I/O operation codes</A>
    DiskFileB::<B>df_READ</B>,         // A read was performed
    DiskFileB::<B>df_WRITE</B>,        // A write operation was performed
    DiskFileB::<B>df_REWIND</B>,       // A rewind operation was performed
    DiskFileB::<B>df_NO_OPERATION</B>  // No operation was performed
  };</PRE>
<P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#DiskFileB">DiskFileB::DiskFileB()</A><BR>
<A HREF="#BM_DiskFileB">DiskFileB::~DiskFileB()</A><BR>
<A HREF="#DiskFileExceptionMessage">DiskFileB::DiskFileExceptionMessage()</A><BR>
<A HREF="#df_ClearErr">DiskFileB::df_ClearErr()</A><BR>
<A HREF="#df_ClearNameBuffer">DiskFileB::df_ClearNameBuffer()</A><BR>
<A HREF="#df_Close">DiskFileB::df_Close()</A><BR>
<A HREF="#df_Copy">DiskFileB::df_Copy()</A><BR>
<A HREF="#df_CreateFile">DiskFileB::df_CreateFile()</A><BR>
<A HREF="#df_EOF">DiskFileB::df_EOF()</A><BR>
<A HREF="#df_Exists">DiskFileB::df_Exists()</A><BR>
<A HREF="#df_FileLength">DiskFileB::df_FileLength()</A><BR>
<A HREF="#df_FilePosition">DiskFileB::df_FilePosition()</A><BR>
<A HREF="#df_FileSize">DiskFileB::df_FileSize()</A><BR>
<A HREF="#df_FileStream">DiskFileB::df_FileStream()</A><BR>
<A HREF="#df_Flush">DiskFileB::df_Flush()</A><BR>
<A HREF="#df_GenOutputFileName">DiskFileB::df_GenOutputFileName()</A><BR>
<A HREF="#df_Get">DiskFileB::df_Get()</A><BR>
<A HREF="#df_GetFileError">DiskFileB::df_GetFileError()</A><BR>
<A HREF="#df_GetLine">DiskFileB::df_GetLine()</A><BR>
<A HREF="#df_HasDriveLetter">DiskFileB::df_HasDriveLetter()</A><BR>
<A HREF="#df_IsDirectory">DiskFileB::df_IsDirectory()</A><BR>
<A HREF="#df_IsFile">DiskFileB::df_IsFile()</A><BR>
<A HREF="#df_IsOK">DiskFileB::df_IsOK()</A><BR>
<A HREF="#df_IsOpen">DiskFileB::df_IsOpen()</A><BR>
<A HREF="#df_LastError">DiskFileB::df_LastError()</A><BR>
<A HREF="#df_LastOperation">DiskFileB::df_LastOperation()</A><BR>
<A HREF="#df_LoadNameBuffer">DiskFileB::df_LoadNameBuffer()</A><BR>
<A HREF="#df_MakeDOSPath">DiskFileB::df_MakeDOSPath()</A><BR>
<A HREF="#df_MakeUNIXPath">DiskFileB::df_MakeUNIXPath()</A><BR>
<A HREF="#df_Open">DiskFileB::df_Open()</A><BR>
<A HREF="#df_OpenFileName">DiskFileB::df_OpenFileName()</A><BR>
<A HREF="#df_PathSimplify">DiskFileB::df_PathSimplify()</A><BR>
<A HREF="#df_Put">DiskFileB::df_Put()</A><BR>
<A HREF="#df_ReOpen">DiskFileB::df_ReOpen()</A><BR>
<A HREF="#df_Read">DiskFileB::df_Read()</A><BR>
<A HREF="#df_ReadOnly">DiskFileB::df_ReadOnly()</A><BR>
<A HREF="#df_ReadyForReading">DiskFileB::df_ReadyForReading()</A><BR>
<A HREF="#df_ReadyForWriting">DiskFileB::df_ReadyForWriting()</A><BR>
<A HREF="#df_Rewind">DiskFileB::df_Rewind()</A><BR>
<A HREF="#df_Seek">DiskFileB::df_Seek()</A><BR>
<A HREF="#df_SeekTo">DiskFileB::df_SeekTo()</A><BR>
<A HREF="#df_Write">DiskFileB::df_Write()</A><BR>
<A HREF="#df_chdir">DiskFileB::df_chdir()</A><BR>
<A HREF="#df_chmod">DiskFileB::df_chmod()</A><BR>
<A HREF="#df_copy">DiskFileB::df_copy()</A><BR>
<A HREF="#df_mkdir">DiskFileB::df_mkdir()</A><BR>
<A HREF="#df_pwd">DiskFileB::df_pwd()</A><BR>
<A HREF="#df_remove">DiskFileB::df_remove()</A><BR>
<A HREF="#df_rename">DiskFileB::df_rename()</A><BR>
<A HREF="#df_rmdir">DiskFileB::df_rmdir()</A><BR>
<A HREF="#operator!">DiskFileB::operator!()</A><BR>
<A HREF="#operator_">DiskFileB::operator=()</A></P>
<B><FONT COLOR="#000080"><P><A NAME="DiskFileB">DiskFileB::DiskFileB()</A></B></FONT>&nbsp;-&nbsp;Default class constructor </P>
<B><FONT COLOR="#000080"><P><A NAME="DiskFileB_overload_1">DiskFileB::DiskFileB(const char *fname, int mode=DiskFileB::df_READONLY, int create=DiskFileB::df_NO_CREATE, int truncate=DiskFileB::df_APPEND,int sharing=DiskFileB::df_SHARE)</A></B></FONT>&nbsp;-&nbsp;Class constructor used to open a specified file. The "mode", "create", "truncate", and "sharing" variables must correspond to one of the integer constant defined in the DiskFileB <A HREF="#AccessModeEnumeration">access/open</A> mode enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="DiskFileB_overload_2">DiskFileB::DiskFileB(const DiskFileB &amp;ob)</A></B></FONT>&nbsp;-&nbsp;Protected copy constructor used by a derived class to copy DiskFileB objects.</P>
<B><FONT COLOR="#000080"><P><A NAME="BM_DiskFileB">virtual DiskFileB::~DiskFileB()</A></B></FONT>&nbsp;-&nbsp;Class destructor responsible for closing any open files. </P>
<B><FONT COLOR="#000080"><P><A NAME="DiskFileExceptionMessage">const char *DiskFileB::DiskFileExceptionMessage()</A></B></FONT>&nbsp;-&nbsp;Public member function used to retrieve the last reported file error in the form of a null terminated string that can be used to log or print a disk file exception.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ClearErr">void DiskFileB::df_ClearErr()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear the last reported file error.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ClearNameBuffer">void DiskFileB::df_ClearNameBuffer()</A></B></FONT>&nbsp;-&nbsp;Protected member function used to clear the open file name.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Close">virtual int DiskFileB::df_Close()</A></B></FONT>&nbsp;-&nbsp;Public member function used to close a previously opened file. Returns a DiskFileB::df_CLOSE_ERROR error code if an error was encountered or zero to indicate success. </P>
<B><FONT COLOR="#000080"><P>void DiskFileB::df_Copy(const DiskFileB &amp;ob)</B></FONT>&nbsp;-&nbsp;Protected member function member function used to copy DiskFileB objects. <B>NOTE</B>: A derived class should never allow copying or assignment unless each copy is accounted for by reference counting or some other method.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_CreateFile">virtual int DiskFileB::df_CreateFile(const char *fname)</A></B></FONT>&nbsp;-&nbsp;Public member function used to create the specified file. Returns zero if the file was created with no errors or a non-zero value to indicate a failure.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_EOF">int DiskFileB::df_EOF()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the end of file has been reached.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Exists">int DiskFileB::df_Exists(const char *name)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the specified file exists.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_FileLength">df_StreamPos DiskFileB::df_FileLength()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the length of the open file.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_FilePosition">virtual df_StreamPos DiskFileB::df_FilePosition(int operation=DiskFileB::df_NO_OPERATION)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the current file position after a read, write, or rewind operation. Returns -1 if an error occurred or an invalid operation was performed. If no operation is specified the last operation performed will be used to determine the current get or put pointer position in the file stream. The "operation" variable must correspond to one of the integer constants defined in the DiskFileB <A HREF="#IO_OperationEnumeration">I/O operation</A> enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_FileSize">df_StreamPos DiskFileB::df_FileSize(const char *fname)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the file size of the specified file.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_FileStream">fstream *DiskFileB::df_FileStream()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a pointer to current fstream object.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Flush">virtual int DiskFileB::df_Flush()</A></B></FONT>&nbsp;-&nbsp;Public member function used to flush any open disk buffers. Returns a DiskFileB::df_FLUSH_ERROR error code if an error was encountered or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_GenOutputFileName">int DiskFileB::df_GenOutputFileName(const char *current_file, char *out_file, const char *extension)</A></B></FONT>&nbsp;-&nbsp;Public member function used to generate a name for the output file using the "current_file" name with the specified dot extension. <B>NOTE</B>: This function assumes that the necessary memory has already been allocated for the "out_file" variable by the calling function. Returns a non-zero value if any errors occur.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Get">virtual int DiskFileB::df_Get(char &amp;c)</A></B></FONT>&nbsp;-&nbsp;Public member function used to get a single character from the open file. Returns zero if no errors occur or a non-zero value to indicate a failure during a get call.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_GetFileError">char *DiskFileB::df_GetFileError(int error_code)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a null terminated string that represents the specified error code.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_GetFileError_overload_1">char *DiskFileB::df_GetFileError()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a null terminated string that represents the last reported file error.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_GetLine">virtual int DiskFileB::df_GetLine(void *buf, unsigned bytes=df_MAX_LINE_LENGTH)</A></B></FONT>&nbsp;-&nbsp;Public member function used to get a line of text from the open file. Returns zero if no errors occur or a non-zero value to indicate a failure during a getline call. <B>NOTE</B>: This function assumes that a buffer equal to the size of the "bytes" variable has already been allocated.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_HasDriveLetter">int DiskFileB::df_HasDriveLetter(const char *dir_name, char &amp;letter)</A></B></FONT>&nbsp;-&nbsp;Public member function used under DOS and WIN32 file systems to parse the drive letter from the specified directory. Returns false if the path does not contain a drive letter. If a drive letter is found it will be passed back in the "letter" variable.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_IsDirectory">int DiskFileB::df_IsDirectory(const char *dir_name)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the specified name is a directory.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_IsFile">int DiskFileB::df_IsFile(const char *fname)</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the specified name is any kind of file or false if this is a directory.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_IsOK">int DiskFileB::df_IsOK()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the file status is ok.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_IsOpen">int DiskFileB::df_IsOpen()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the file is open.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_LastError">int DiskFileB::df_LastError()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the last reported file error. The return value will correspond to one of the integer constants defined in the DiskFileB <A HREF="#ErrorCodeEnumeration">error code</A> enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_LastOperation">int DiskFileB::df_LastOperation()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the last operation performed. The return value will correspond to one of the integer constants defined in the DiskFileB <A HREF="#IO_OperationEnumeration">I/O operation</A> enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_LoadNameBuffer">void DiskFileB::df_LoadNameBuffer(const char *s)</A></B></FONT>&nbsp;-&nbsp;Protected member function used to set the open file name.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_MakeDOSPath">void DiskFileB::df_MakeDOSPath(char *path)</A></B></FONT>&nbsp;-&nbsp;Public member function used to make a DOS directory path by replacing all forward slash path separators with back slashes.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_MakeUNIXPath">void DiskFileB::df_MakeUNIXPath(char *path)</A></B></FONT>&nbsp;-&nbsp;Public member function used to make a UNIX directory path by replacing all back slash path separators with forward slashes.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Open">virtual int DiskFileB::df_Open(const char *fname, int mode=DiskFileB::df_READONLY, int create=DiskFileB::df_NO_CREATE, int truncate=DiskFileB::df_APPEND, int sharing=DiskFileB::df_SHARE,fstream *f=0)</A></B></FONT>&nbsp;-&nbsp;Public member function used to open the specified file. The "mode", "create", "truncate", and "share" values must correspond to one of the integer constants defined in the DiskFileB <A HREF="#AccessModeEnumeration">access/open mode</A> enumeration. If no fstream pointer is specified an internal fstream object will be used. Returns zero if no errors occur or a non-zero value if an error is encountered during an open call.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_OpenFileName">char *DiskFileB::df_OpenFileName()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the open file name in the form of a null-terminated string.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_PathSimplify">void DiskFileB::df_PathSimplify(const char *path, char *new_path, char path_sep = '/')</A></B></FONT>&nbsp;-&nbsp;Public member function used to simplify a path and return a new path. The path separator should either be a forward slash for UNIX file systems or a backslash for DOS/WIN32 file systems. If no path separator is specified a forward slash will be used by default. Multiple path separators will be collapsed to a single path separator. Leading `./' paths and trailing `/.' paths will be removed. Trailing path separators will be removed. All non-leading `../' paths and trailing `..' paths are handled by removing portions of the path. <B>NOTE</B>: This function assumes that the necessary memory has already been allocated for the "new_path" variable by the calling function.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Put">virtual int DiskFileB::df_Put(const char &amp;c)</A></B></FONT>&nbsp;-&nbsp;Public member function used to put a single character into the open file. Returns zero if no errors occur or a non-zero value if an error is encountered during a put call.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ReOpen">virtual int DiskFileB::df_ReOpen(fstream *f, int mode=DiskFileB::df_READONLY)</A></B></FONT>&nbsp;-&nbsp;Public member function used to connect the file object pointer to another pointer. This function assumes the file has been opened by the calling function. The calling function must tell this function if the file was opened for read, write, or read/write access.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Read">virtual int DiskFileB::df_Read(void *buf, unsigned bytes, df_StreamPos position=df_CurrPosition)</A></B></FONT>&nbsp;-&nbsp;Public member function used to read a specified number of bytes into a buffer. Returns zero if no errors occur or a non-zero value if an error is encountered during a read call.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ReadOnly">int DiskFileB::df_ReadOnly()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if this is a read only file.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ReadyForReading">int DiskFileB::df_ReadyForReading()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the file is ready for reading.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_ReadyForWriting">int DiskFileB::df_ReadyForWriting()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the file is ready for writing.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Rewind">virtual int DiskFileB::df_Rewind()</A></B></FONT>&nbsp;-&nbsp;Public member function used to rewind the file get and put pointers to zero and flush any open disk buffers. Returns a DiskFileB::df_REWIND_ERROR error code if an error was encountered or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Seek">virtual int DiskFileB::df_Seek(df_StreamPos position, int seek_mode=df_SEEK_BEG, int operation=df_NO_OPERATION)</A></B></FONT>&nbsp;-&nbsp;Public member function used to move the file offset to the specified file position. Returns a DiskFileB::df_SEEK_ERROR if an error occurred during a file seek. If no operation is specified both the get and put offsets will be moved to the specified position. The "seek_mode" variable must correspond to one of the integer constants defined in the DiskFileB <A HREF="#SeekModeEnumeration">seek mode</A> enumeration. The "operation" variable must correspond to one of the integer constants defined in the DiskFileB <A HREF="#IO_OperationEnumeration">I/O operation</A> enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_SeekTo">virtual df_StreamPos DiskFileB::df_SeekTo(df_StreamPos position, int operation=df_NO_OPERATION)</A></B></FONT>&nbsp;-Public member function used to seek to the specified position, optimizing the seek operation by moving the file position indicator based on the current stream position. Returns the current file position after performing the "seek to" operation. The "operation" variable must correspond to one of the integer constants defined in the DiskFileB <A HREF="#IO_OperationEnumeration">I/O operation</A> enumeration.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_Write">virtual int DiskFileB::df_Write(const void *buf, unsigned bytes, df_StreamPos position=df_CurrPosition)</A></B></FONT>&nbsp;-&nbsp;Public member function used to write a specified number of bytes from a buffer to the open file. Returns zero if no errors occur or a non-zero value if an error is encountered during a write call.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_chdir">int DiskFileB::df_chdir(const char *dir_name)</A></B></FONT>&nbsp;-&nbsp;Public member function use to change the current working directory. Returns zero if successful.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_chmod">int DiskFileB::df_chmod(const char *fname, int pmode)</A></B></FONT>&nbsp;-&nbsp;Public member function used to change the file-permission settings. The "pmode" variable should be equal to DiskFileB::df_READONLY, DiskFileB::df_WRITEONLY, or DiskFileB::df_READWRITE. Returns a non-zero value if an error occurs or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_copy">int DiskFileB::df_copy(const char *from, const char *to)</A></B></FONT>&nbsp;-&nbsp;Public member function used to copy a file. Returns a non-zero value if an error occurs or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_mkdir">int DiskFileB::df_mkdir(const char *dir_name)</A></B></FONT>&nbsp;-&nbsp;Public member function used to make the specified directory if it does not exist. Returns a non-zero value if an error occurs. <B>NOTE</B>: UNIX file systems will use 755 permissions when new directories are created.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_pwd">int DiskFileB::df_pwd(char *dir, unsigned max_len = df_MAX_DIR_LENGTH)</A></B></FONT>&nbsp;-&nbsp;Public member function that passes back the present working directory in the "dir" variable. Returns false if an error occurs. <B>NOTE</B>: This function assumes that the required amount of memory has already been allocated for the "dir" pointer. The "max_len" value must be at least one byte greater than the length of the pathname to be returned.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_remove">int DiskFileB::df_remove(const char *fname)</A></B></FONT>&nbsp;-&nbsp;Public member function used to delete a file. Returns a non-zero value if an error occurs or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_rename">int DiskFileB::df_rename(const char *oldname, const char *newname)</A></B></FONT>&nbsp;-&nbsp;Public member function used to rename a file. Returns a non-zero value if an error occurs or zero to indicate success.</P>
<B><FONT COLOR="#000080"><P><A NAME="df_rmdir">int DiskFileB::df_rmdir(const char *dir_name)</A></B></FONT>&nbsp;-&nbsp;Public member function used to remove the specified directory. Returns zero if successful or a non-zero value to indicate a failure. <B>NOTE</B>: The directory must be empty and not be the current working directory or the root directory.</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Fixed Length String </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Fixed Length String</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#ConditionalDirectives">Conditional Directives</A><BR>
<A HREF="#Constants">Constants</A><BR>
<A HREF="#DataMembers">Data Members</A><BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The fixed length string class used by database key types or members that must be fixed in length.</P>
<P><HR></P>
<P><!-- New Section --><A NAME="ConditionalDirectives"><B><FONT SIZE=4>Conditional Directives</A></B></FONT> </P>
<P>The following conditional directives are used to define non-portable string routines that need to be ported between UNIX and WIN32 platforms.</P>
<B><P>__DOS__</B> - Directive used for all DOS compilers </P>
<B><P>__UNIX__</B> - Directive used for all UNIX compilers</P>
<B><P>__WIN32__</B> - Directive used for all WIN32 compilers</P>
<P><HR></P>
<P><!-- New Section --><A NAME="Constants"><B><FONT SIZE=4>Constants</A></B></FONT> </P>
<P>The length constant sets the string length for all FString objects. The total length for all FString objects is equal to the length specified in this constant plus one byte for a null terminator.</P>
<PRE>const unsigned FStringLength = 255; // Length not including null terminator</PRE>
<P><HR></P>
<P><A NAME="DataMembers"><!-- New Section --><B><FONT SIZE=4>Public Data Members</B></FONT> </A></P>
<B><FONT COLOR="#000080"><P>char FString::sptr[FStringLength+1]</B></FONT>- Fixed string buffer equal to the fixed length plus a null terminator.</P>
<P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#FString">FString::FString()</A><BR>
<A HREF="#FStringDestrcutor">FString::~FString()</A><BR>
<A HREF="#Clear">FString::Clear()</A><BR>
<A HREF="#Copy">FString::Copy()</A><BR>
<A HREF="#SetString">FString::SetString()</A><BR>
<A HREF="#SizeOf">FString::SizeOf()</A><BR>
<A HREF="#c_str">FString::c_str()</A><BR>
<A HREF="#is_null">FString::is_null()</A><BR>
<A HREF="#length">FString::length()</A><BR>
<A HREF="#strdup">FString::strdup()</A><BR>
<A NAME="FString"><A HREF="#OverloadedOperators">FString Overloaded Operators</A><BR>
<A HREF="#StandaloneFunctions">Standalone Helper Functions</A></P>
<B><FONT COLOR="#000080"><P>FString::FString()</A></B></FONT>&nbsp;-&nbsp;Default class constructor. </P>
<B><FONT COLOR="#000080"><P><A NAME="FString_overload_1">FString::FString(const char *s, unsigned bytes = 0)</A></B></FONT>&nbsp;-&nbsp;Class constructor used to construct a FString object and load the specified string in memory. This constructor will truncate the number of bytes requested if the number of bytes exceeds maximum fixed string length. By Default this constructor assumes that "s" is a null terminated string. If a byte size is specified by the "bytes" variable the string is treated as raw pattern of bytes and a null terminator is not required.</P>
<B><FONT COLOR="#000080"><P><A NAME="FString_overload_2">FString::FString(const FString &amp;s)</A></B></FONT>&nbsp;-&nbsp;Class copy constructor. This copy constructor does not use share semantics and guarantees that each copy will be unique.</P>
<B><FONT COLOR="#000080"><P><A NAME="FStringDestrcutor">FString::~FString()</A></B></FONT>&nbsp;-&nbsp;Class destructor.</P>
<B><FONT COLOR="#000080"><P><A NAME="Clear">void FString::Clear()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear the string.</P>
<B><FONT COLOR="#000080"><P><A NAME="Copy">void FString::Copy(const FString &amp;s)</A></B></FONT>&nbsp;-&nbsp;Public member function used to uniquely copy string objects</P>
<B><FONT COLOR="#000080"><P><A NAME="SetString">int FString::SetString(const char *s, unsigned bytes = 0)</A></B></FONT>&nbsp;-&nbsp;Public member function used to set the string value for this object. This function will truncate the number of bytes requested if the number of bytes exceeds maximum fixed string length. Returns true if successful or false if the string was truncated. <B>NOTE</B>: The FString class guarantees that each string object is unique by storing a unique copy of the string with each object. This ensures that FString objects can be safely copy constructed, assigned, resized, and deleted by multiple threads. Multiple threads accessing shared memory segments must be handled by the application.</P>
<B><FONT COLOR="#000080"><P><A NAME="SizeOf">size_t FString::SizeOf()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the size of an FString object.</P>
<B><FONT COLOR="#000080"><P><A NAME="c_str">char *FString::c_str()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the null terminated string this object is referencing. </P>
<B><FONT COLOR="#000080"><P><A NAME="is_null">int FString::is_null()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if this string is null. </P>
<B><FONT COLOR="#000080"><P><A NAME="length">unsigned FString::length()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the string length of this string. </P>
<B><FONT COLOR="#000080"><P><A NAME="strdup">FString *FString::strdup()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a duplicate string object or a null value if an error occurs.</P>
<B><U><P><A NAME="OverloadedOperators">Overloaded operators</A></B></U>:<BR>
<B><FONT COLOR="#000080">friend int operator==(const FString &amp;a, const FString &amp;b)</B></FONT> - Overloaded operator that returns true if its operands are equal to each other. <B>NOTE</B>: Applications can force a case insensitive compare by setting the <B>FStringCaseCompare</B> global variable to 0. By default a case sensitive compare is used.</P>
<B><FONT COLOR="#000080"><P>friend int operator!=(const FString &amp;a, const FString &amp;b)</B></FONT> - Overloaded operator that returns true if its operands are not equal to each other. <B>NOTE</B>: Applications can force a case insensitive compare by setting the <B>FStringCaseCompare</B> global variable to 0. By default a case sensitive compare is used.</P>
<B><FONT COLOR="#000080"><P>friend int operator&gt;(const FString &amp;a, const FString &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is greater then "b. <B>NOTE</B>: Applications can force a case insensitive compare by setting the <B>FStringCaseCompare</B> global variable to 0. By default a case sensitive compare is used.</P>
<B><FONT COLOR="#000080"><P>friend int operator&lt;(const FString &amp;a, const FString &amp;b)</B></FONT> - Overloaded operator that returns true if its operand "a" is less then "b." <B>NOTE</B>: Applications can force a case insensitive compare by setting the <B>FStringCaseCompare</B> global variable to 0. By default a case sensitive compare is used.</P>
<B><U><P><A NAME="StandaloneFunctions">Standalone Helper Functions</A></B></U>:<BR>
<B><FONT COLOR="#000080">int CaseICmp(const FString &amp;s1, const FString &amp;s2)</B></FONT> - Compare two FString objects without regard to the case of the letters. Returns -1 if a &lt; b, 0 if a == b, and 1 if a &gt; b </P>
<B><FONT COLOR="#000080"><P>int CaseICmp(const FString &amp;s1, const char *s)</B></FONT> - Compare a FString object to a null terminated string without regard to the case of the letters. Returns -1 if a &lt; b, 0 if a == b, and 1 if a &gt; b</P>
<B><FONT COLOR="#000080"><P>int CaseICmp(const char *s, const FString &amp;s2)</B></FONT> - Compare a null terminated string to a FString object without regard to the case of the letters. Returns -1 if a &lt; b, 0 if a == b, and 1 if a &gt; b</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

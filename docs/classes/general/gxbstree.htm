<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Binary Search Tree </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Binary Search Tree</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Structs">Data Structures</A><BR>
<A HREF="#Functions">Functions</A><BR>
<A HREF="#Iterator">Tree Iterator</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The gxBStreeNode_t, gxBStree, and gxBStreeNode classes makeup a generic binary search tree class. This tree implementation is designed to work with minimum overhead by eliminating excessive pointer manipulation and execution cycles associated with tree rotations and balancing. </P>
<P>A tree is a recursive data structure used to store a hierarchical collection of nodes starting at a root node pointing down to parent and child nodes to leaf nodes (nodes with no children). A node is a container used to store left and right pointers to other nodes and some type of data. Unlike linked lists, where only forward and backward movements are allowed, trees allow left and right movements. A binary search tree is a tree that uses binary nodes (nodes with no more then two children) kept in sort order, with smaller nodes on the left and larger nodes on the right. The height of a tree is maximum number of nodes that must be visited on any path from the root to a leaf. In a binary search tree the efficiency of the tree depends on the height of the tree.</P>
<P><HR></P>
<P><!-- New Section --><A NAME="Structs"><B><FONT SIZE=4>Data Structures</A></B></FONT> </P>
<P>The tree node type is a data structure used to store left and right pointers. It is a reusable base class that can be shared by multiple tree implementations regardless of the data type.</P>
<FONT COLOR="#008080"><PRE>struct gxBStreeNode_t
{
  gxBStreeNode_t *left;  // Pointer to the left sub-tree
  gxBStreeNode_t *right; // Pointer to the right sub-tree
};</PRE>
</FONT><P>The generic tree node class inherits the tree node type structure and adds a data type to the node.</P>
<FONT COLOR="#008080"><PRE>template&lt;class TYPE&gt;
class gxBStreeNode : public gxBStreeNode_t
{
public:
  gxBStreeNode() { right = left = 0; }
  gxBStreeNode(TYPE &amp;X) : data(X) { right = left = 0; }
  ~gxBStreeNode() { }

public: // Type-casting functions
  gxBStreeNode *GetLeft() const { return (gxBStreeNode&lt;TYPE&gt; *)left; }
  gxBStreeNode *GetLeft() { return (gxBStreeNode&lt;TYPE&gt; *)left; }
  gxBStreeNode *GetRight() const { return (gxBStreeNode&lt;TYPE&gt; *)right; }
  gxBStreeNode *GetRight() { return (gxBStreeNode&lt;TYPE&gt; *)right; }
  
public:
  TYPE data; // User defined node data type
};</PRE>
</FONT><P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#gxBStree">gxBStree::gxBStree()</A><BR>
<A HREF="#gxBStreeDestructor">gxBStree::~gxBStree()</A><BR>
<A HREF="#Clear">gxBStree::Clear()</A><BR>
<A HREF="#Delete">gxBStree::Delete()</A><BR>
<A HREF="#DeleteTree">gxBStree::DeleteTree()</A><BR>
<A HREF="#DetachNode">gxBStree::DetachNode()</A><BR>
<A HREF="#ExtractFirst">gxBStree::ExtractFirst()</A><BR>
<A HREF="#ExtractLast">gxBStree::ExtractLast()</A><BR>
<A HREF="#Find">gxBStree::Find()</A><BR>
<A HREF="#FindFirst">gxBStree::FindFirst()</A><BR>
<A HREF="#FindLast">gxBStree::FindLast()</A><BR>
<A HREF="#GetRoot">gxBStree::GetRoot()</A><BR>
<A HREF="#Insert">gxBStree::Insert()</A><BR>
<A HREF="#IsEmpty">gxBStree::IsEmpty()</A><BR>
<A NAME="gxBStree"></P>
<B><FONT COLOR="#000080"><P>gxBStree::gxBStree()</A></B></FONT>&nbsp;-&nbsp;Default class constructor.</P>
<B><FONT COLOR="#000080"><P><A NAME="gxBStree_overload_1">gxBStree::gxBStree(const gxBStree&lt;TYPE&gt; &amp;ob)</A></B></FONT>&nbsp;-&nbsp;Private class copy constructor used to disallow copying.</P>
<B><FONT COLOR="#000080"><P><A NAME="gxBStreeDestructor">void gxBStree::operator=(const gxBStree&lt;TYPE&gt; &amp;ob)</B></FONT>&nbsp;-&nbsp;Private assignment operator used to disallow assignment.</P>
<B><FONT COLOR="#000080"><P>gxBStree::~gxBStree()</A></B></FONT>&nbsp;-&nbsp;Class destructor responsible for clearing the tree when a tree object is destroyed.</P>
<B><FONT COLOR="#000080"><P><A NAME="Clear">void gxBStree::Clear()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear the tree. </P>
<B><FONT COLOR="#000080"><P><A NAME="Delete">int gxBStree::Delete(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to delete the specified entry from the tree. Returns false if the entry does not exist.</P>
<B><FONT COLOR="#000080"><P><A NAME="DeleteTree">void gxBStree::DeleteTree(gxBStreeNode&lt;TYPE&gt; *tree)</A></B></FONT>&nbsp;-&nbsp;Private member function used to recursively clear the tree from the bottom up. <B>NOTE</B>: The node data must be destroyed by the TYPE destructor or the memory for the node data will not be released.</P>
<B><FONT COLOR="#000080"><P><A NAME="DetachNode">gxBStreeNode&lt;TYPE&gt; *gxBStree::DetachNode(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Private member function used to detach the node from its current position. Returns a pointer to the detached node or a null value if the node was not found.</P>
<B><FONT COLOR="#000080"><P><A NAME="ExtractFirst">int gxBStree::ExtractFirst(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public queue operation used to extract the first node from the tree in sort order. Returns true if the node was extracted.</P>
<B><FONT COLOR="#000080"><P><A NAME="ExtractLast">int gxBStree::ExtractLast(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public queue operation used to extract the last node from the tree in sort order. Returns true if the node was extracted.</P>
<B><FONT COLOR="#000080"><P><A NAME="Find">int gxBStree::Find(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to search the tree for the specified entry. Return true if the entry was found or false if the entry does not exist.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindFirst">int gxBStree::FindFirst(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the left most node in the tree. Returns false if the tree is empty.</P>
<B><FONT COLOR="#000080"><P><A NAME="FindLast">int gxBStree::FindLast(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to find the right most node in the tree. Returns false if the tree is empty.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetRoot">gxBStreeNode&lt;TYPE&gt; *gxBStree::GetRoot()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns a pointer to the root node.</P>
<B><FONT COLOR="#000080"><P><A NAME="Insert">int gxBStree::Insert(TYPE &amp;X, int *exists = 0)</A></B></FONT>&nbsp;-&nbsp;Public unbalanced tree insertion routine used to insert a node into the tree. Returns false is an error occurs or the node already exists. If the "exists" variable is initialized by the application, the "exists" variable will be set to true if this entry already exists.</P>
<B><FONT COLOR="#000080"><P><A NAME="IsEmpty">int gxBStree::IsEmpty()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the tree is empty</P>
<P><HR></P>
<P><A NAME="Iterator"><!-- New Section --><B><FONT SIZE=4>Binary Search Tree Iterator </A></P>
</B></FONT><P>The binary search tree iterator class is used for sort order tree iterations. It uses an external stack to traverse the tree in order. </P>
<B><U><P>Functions</B></U>:<BR>
<B><FONT COLOR="#000080">gxBStreeIterator::gxBStreeIterator(gxBStreeNode_t *node) </B></FONT>- Class constructor used to construct and initialize a tree iterator object. </P>
<B><FONT COLOR="#000080"><P>gxBStreeNode_t *gxBStreeIterator::GetNext()</B></FONT> - Public member function that returns the next node in the tree in sort order.</P>
<B><FONT COLOR="#000080"><P>void gxBStreeIterator::Reset(gxBStreeNode_t *node)</B></FONT> - Public member function used to initialize the tree iterator object.</P>
<B><FONT COLOR="#000080"><P>void gxBStreeIterator::Reset()</B></FONT> - Public member function used to reset the tree iterator if this object has been previously initialized.</P>
<B><U><P>Example</B></U>:</P>
<PRE>void ListInOrder(gxBStree&lt;UString&gt; &amp;tree)
<FONT COLOR="#ff0000">// List all the tree nodes using a tree iterator object.
</FONT>{
  gxBStreeNode&lt;UString&gt; *node = tree.GetRoot();
  gxBStreeIterator tree_iterator(node);
  while((node = (gxBStreeNode&lt;UString&gt; *)tree_iterator.GetNext()) != 0) {
    cout &lt;&lt; node-&gt;data &lt;&lt; endl;
  }
  cout &lt;&lt; endl;
}</PRE>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

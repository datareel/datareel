<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Linked List Class </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Linked List Class</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Structs">Data Structures</A><BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The gxListNode and gxList classes makeup a generic doubly linked-list class that includes stack and queue functions. </P>
<P>A <A HREF="#Functions">linked-list</A> is a non-contiguous data structure used to link a collection of nodes together. A node is a container used to store pointers to other nodes and some type of data. In a doubly linked list each node stores a data item and pointers to the next node and previous node in sequence allowing the list nodes to be processed in two directions.</P>
<P>A <A HREF="#StackFunctions">stack</A> is a data structure that stores nodes in last-in-first-out (LIFO) order using push and pop operations. A push operation adds a new node to the top of the stack and a pop operation removes a node from the top of the stack.</P>
<P>A <A HREF="#QueueFunctions">queue</A> is a data structure that stores node in first-in-first-out (FIFO) order using insert and extract operations. An insert operation adds a new node to tail of the queue and an extract operation removes a node from the head of the queue. </P>
<P><HR></P>
<P><!-- New Section --><A NAME="Structs"><B><FONT SIZE=4>Data Structures</A></B></FONT> </P>
<P>The linked-list node structure is a generic class used to store the node data, previous and next pointers.</P>
<FONT COLOR="#008080"><PRE>template&lt;class TYPE&gt;
class gxListNode
{
public:
  gxListNode() { next = prev = 0; }
  gxListNode(TYPE &amp;X) : data(X) { next = prev = 0; }
  ~gxListNode() { }

public: 
  TYPE data; // Node data
  gxListNode&lt;TYPE&gt; *next; // Pointer to the next node in the list
  gxListNode&lt;TYPE&gt; *prev; // Pointer to the previous node in the list
};</PRE>
</FONT><P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#gxList">gxList::gxList()</A><BR>
<A HREF="#gxListDestructor">gxList::~gxList()</A><BR>
<A HREF="#Add">gxList::Add()</A><BR>
<A HREF="#AddAfter">gxList::AddAfter()</A><BR>
<A HREF="#AddBefore">gxList::AddBefore()</A><BR>
<A HREF="#AddToBack">gxList::AddToBack()</A><BR>
<A HREF="#AddToFront">gxList::AddToFront()</A><BR>
<A HREF="#AllocNode">gxList::AllocNode()</A><BR>
<A HREF="#ClearList">gxList::ClearList()</A><BR>
<A HREF="#DestroyList">gxList::DestroyList()</A><BR>
<A HREF="#DetachNode">gxList::DetachNode()</A><BR>
<A HREF="#FreeNode">gxList::FreeNode()</A><BR>
<A HREF="#GetHead">gxList::GetHead()</A><BR>
<A HREF="#GetTail">gxList::GetTail()</A><BR>
<A HREF="#InsertAfter">gxList::InsertAfter()</A><BR>
<A HREF="#InsertAtHead">gxList::InsertAtHead()</A><BR>
<A HREF="#InsertAtTail">gxList::InsertAtTail()</A><BR>
<A HREF="#InsertBefore">gxList::InsertBefore()</A><BR>
<A HREF="#IsEmpty">gxList::IsEmpty()</A><BR>
<A HREF="#MakeEmpty">gxList::MakeEmpty()</A><BR>
<A HREF="#MoveAfter">gxList::MoveAfter()</A><BR>
<A HREF="#MoveBefore">gxList::MoveBefore()</A><BR>
<A HREF="#MoveToBack">gxList::MoveToBack()</A><BR>
<A HREF="#MoveToFront">gxList::MoveToFront()</A><BR>
<A HREF="#Remove">gxList::Remove()</A><BR>
<A HREF="#RemoveHead">gxList::RemoveHead()</A><BR>
<A HREF="#RemoveTail">gxList::RemoveTail()</A></P>
<B><U><P><A NAME="StackFunctions">Stack Functions</A></B></U>:<BR>
<A HREF="#Pop">gxList::Pop()</A><BR>
<A HREF="#Push">gxList::Push()</A> </P>
<B><U><P><A NAME="QueueFunctions">Queue Functions</A></B></U>: <BR>
<A NAME="gxList"><A HREF="#Insert">gxList::Insert()</A><BR>
<A HREF="#Extract">gxList::Extract()</A> </P>
<B><FONT COLOR="#000080"><P>gxList::gxList()</A></B></FONT>&nbsp;-&nbsp;Default class constructor. </P>
<B><FONT COLOR="#000080"><P><A NAME="gxList_overload_1">gxList::gxList(const gxList&lt;TYPE&gt; &amp;ob)</A></B></FONT>&nbsp;-&nbsp;Private class copy constructor used to disallow copying. </P>
<B><FONT COLOR="#000080"><P>void gxList::operator=(const gxList&lt;TYPE&gt; &amp;ob)</B></FONT>&nbsp;-&nbsp;Private assignment operator used to disallow assignment.</P>
<B><FONT COLOR="#000080"><P><A NAME="gxListDestructor">gxList::~gxList()</A></B></FONT>&nbsp;-&nbsp;Class destructor responsible for clearing the list when a list object is destroyed.</P>
<B><FONT COLOR="#000080"><P><A NAME="Add">gxListNode&lt;TYPE&gt; *gxList::Add(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to add a new list node to the back of the list. Returns a pointer to the newly created node or a null value if heap space could not be allocated for the node.</P>
<B><FONT COLOR="#000080"><P><A NAME="AddAfter">gxListNode&lt;TYPE&gt; *gxList::AddAfter(gxListNode&lt;TYPE&gt; *pos, TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to add a list node after the specified node. Returns a pointer to the newly created node or a null value if heap space could not be allocated for the node.</P>
<B><FONT COLOR="#000080"><P><A NAME="AddBefore">gxListNode&lt;TYPE&gt; *gxList::AddBefore(gxListNode&lt;TYPE&gt; *pos, TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to add a list node before the specified node. Returns a pointer to the newly created node or a null value if heap space could not be allocated for the node.</P>
<B><FONT COLOR="#000080"><P><A NAME="AddToBack">gxListNode&lt;TYPE&gt; *gxList::AddToBack(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to add a list node to the back of the list. Returns a pointer to the newly created node or a null value if heap space could not be allocated for the node.</P>
<B><FONT COLOR="#000080"><P><A NAME="AddToFront">gxListNode&lt;TYPE&gt; *gxList::AddToFront(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to add a list node to the front of the list. Returns a pointer to the newly created node or a null value if heap space could not be allocated for the node.</P>
<B><FONT COLOR="#000080"><P><A NAME="AllocNode">gxListNode&lt;TYPE&gt; *gxList::AllocNode(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Private member function used to allocate a new list node.</P>
<B><FONT COLOR="#000080"><P><A NAME="ClearList">void gxList::ClearList()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="DestroyList">void gxList::DestroyList()</A></B></FONT>&nbsp;-&nbsp;Public member function used to clear the list and destroy the node data.</P>
<B><FONT COLOR="#000080"><P><A NAME="DetachNode">void gxList::DetachNode(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to detach the node from its current location.</P>
<B><FONT COLOR="#000080"><P><A NAME="Extract">int gxList::Extract(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public queue operation used to extract a list node from the list. Returns true if the node was extracted.</P>
<B><FONT COLOR="#000080"><P><A NAME="FreeNode">int gxList::FreeNode(gxListNode&lt;TYPE&gt; *n, TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Private member function used to free the memory location of the node without releasing the nodes data pointer. <B>NOTE</B>: This function assumes that the node has already been detached from the list. Returns a true if the node was deleted.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetHead">gxListNode&lt;TYPE&gt; *gxList::GetHead()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the head of the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetTail">gxListNode&lt;TYPE&gt; *gxList::GetTail()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the tail of the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="Insert">gxListNode&lt;TYPE&gt; *gxList::Insert(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public queue operation used to insert a list node into the list. Returns a pointer to the node or a null value if memory for the node could not be allocated. </P>
<B><FONT COLOR="#000080"><P><A NAME="InsertAfter">void gxList::InsertAfter(gxListNode&lt;TYPE&gt; *pos, gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a new or detached node after the node residing at the specified location.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertAtHead">void gxList::InsertAtHead(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a node at the head of the list. </P>
<B><FONT COLOR="#000080"><P><A NAME="InsertAtTail">void gxList::InsertAtTail(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a node at the tail of the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="InsertBefore">void gxList::InsertBefore(gxListNode&lt;TYPE&gt; *pos, gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to insert a new or detached node before the node residing at the specified location.</P>
<B><FONT COLOR="#000080"><P><A NAME="IsEmpty">int gxList::IsEmpty()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if the list is empty.</P>
<B><FONT COLOR="#000080"><P><A NAME="MakeEmpty">void gxList::MakeEmpty()</A></B></FONT>&nbsp;-&nbsp;Public member function used to reset the head and tail pointers. <B>NOTE</B>: This function should only be called only if all the nodes have been removed.</P>
<B><FONT COLOR="#000080"><P><A NAME="MoveAfter">void gxList::MoveAfter(gxListNode&lt;TYPE&gt; *pos, gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to move an existing node after the node residing at the specified location.</P>
<B><FONT COLOR="#000080"><P><A NAME="MoveBefore">void gxList::MoveBefore(gxListNode&lt;TYPE&gt; *pos, gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to move an existing node before the node residing at the specified location.</P>
<B><FONT COLOR="#000080"><P><A NAME="MoveToBack">void gxList::MoveToBack(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to move the specified node to the back of the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="MoveToFront">void gxList::MoveToFront(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to move the specified node to the front of the list.</P>
<B><FONT COLOR="#000080"><P><A NAME="Pop">int gxList::Pop(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public stack operation used to pop a list node from the list. Returns a true if the node was popped.</P>
<B><FONT COLOR="#000080"><P><A NAME="Push">gxListNode&lt;TYPE&gt; *gxList::Push(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public stack operation used to push a list node into the list. Returns a pointer to the node or a null value if memory for the node could not be allocated.</P>
<B><FONT COLOR="#000080"><P><A NAME="Remove">int gxList::Remove(gxListNode&lt;TYPE&gt; *n, TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to remove the specified node from the list and pass back the node data. Returns true if the node was removed.</P>
<B><FONT COLOR="#000080"><P><A NAME="Remove_overload_1">int gxList::Remove(gxListNode&lt;TYPE&gt; *n)</A></B></FONT>&nbsp;-&nbsp;Public member function used to remove the specified node from the list. Returns true if the node was removed.</P>
<B><FONT COLOR="#000080"><P><A NAME="RemoveHead">int gxList::RemoveHead(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to remove the first node in the list. Returns true if the node was removed.</P>
<B><FONT COLOR="#000080"><P><A NAME="RemoveTail">int gxList::RemoveTail(TYPE &amp;X)</A></B></FONT>&nbsp;-&nbsp;Public member function used to remove the last node in the list. Returns true if the node was removed.</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Embedded Telnet Client </TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!-- HTML file generated by: inc2help version 1034.101 --></P>
<H1 ALIGN="CENTER">Embedded Telnet Client</H1>
<P><HR></P>
<B><U><FONT SIZE=4><P>Topics</B></U></FONT>:</P>
<P><A HREF="#Overview">Overview</A><BR>
<A HREF="#Constants">Constants</A><BR>
<A HREF="#Enumerations">Enumerations</A><BR>
<A HREF="#Functions">Functions</A></P>
<P><HR></P>
<P><!-- New Section --><A NAME="Overview"><B><FONT SIZE=4>Overview</A></B></FONT> </P>
<P>The embedded Telnet client is a cross platform Telnet implementation used with applications that require use of the Telnet protocol as a keyboard and screen interface to the TCP stack. The gxsTelnet Client class is derived from the <A HREF="gxsocket.htm">gxSocket</A> class and supports NVT (Network Virtual Terminal) terminal negotiation. The character set is restricted to 7 bits sent as a byte value with the most significant bit cleared. All terminal emulations other then NVT are handled by terminal type set in the environment by the TERM variable. This implementation works well in a UNIX to UNIX environment. However, in a Windows to UNIX environment your application must provide the API to perform specific terminal emulations. </P>
<P><HR></P>
<P><!-- New Section --><A NAME="Constants"><B><FONT SIZE=4>Constants</A></B></FONT> </P>
<PRE>// Telnet command codes
const unsigned char <B>gxsTEL_IAC</B>  = 255; // Interpret as command escape sequence
                                       // Prefix to all telnet commands 
const unsigned char <B>gxsTEL_DONT</B> = 254; // You are not to use this option
const unsigned char <B>gxsTEL_DO</B>   = 253; // Please, you use this option
const unsigned char <B>gxsTEL_WONT</B> = 252; // I won't use option 
const unsigned char <B>gxsTEL_WILL</B> = 251; // I will use option 
const unsigned char <B>gxsTEL_SB   </B>= 250; // Subnegotiate
const unsigned char <B>gxsTEL_GA   </B>= 249; // Go ahead
const unsigned char <B>gxsTEL_EL   </B>= 248; // Erase line          
const unsigned char <B>gxsTEL_EC   </B>= 247; // Erase character
const unsigned char <B>gxsTEL_AYT  </B>= 246; // Are you there
const unsigned char <B>gxsTEL_AO   </B>= 245; // Abort output
const unsigned char <B>gxsTEL_IP   </B>= 244; // Interrupt process
const unsigned char <B>gxsTEL_BRK  </B>= 243; // Break
const unsigned char <B>gxsTEL_DM   </B>= 242; // Data mark
const unsigned char <B>gxsTEL_NOP  </B>= 241; // No operation.
const unsigned char <B>gxsTEL_SE   </B>= 240; // End of subnegotiation
const unsigned char <B>gxsTEL_EOR  </B>= 239; // End of record
const unsigned char <B>gxsTEL_ABORT </B>= 238; // About process
const unsigned char <B>gxsTEL_SUSP  </B>= 237; // Suspend process
const unsigned char <B>gxsTEL_xEOF  </B>= 236; // End of file: EOF already used

// Telnet options 
const unsigned char <B>gxsTELOPT_BIN    </B>= 0;   // Binary transmission
const unsigned char <B>gxsTELOPT_ECHO   </B>= 1;   // Echo
const unsigned char <B>gxsTELOPT_RECN   </B>= 2;   // Reconnection
const unsigned char <B>gxsTELOPT_SUPP   </B>= 3;   // Suppress go ahead
const unsigned char <B>gxsTELOPT_APRX   </B>= 4;   // Approx message size negotiation
const unsigned char <B>gxsTELOPT_STAT   </B>= 5;   // Status
const unsigned char <B>gxsTELOPT_TIM    </B>= 6;   // Timing mark
const unsigned char <B>gxsTELOPT_REM    </B>= 7;   // Remote controlled trans/echo
const unsigned char <B>gxsTELOPT_OLW    </B>= 8;   // Output line width
const unsigned char <B>gxsTELOPT_OPS    </B>= 9;   // Output page size
const unsigned char <B>gxsTELOPT_OCRD   </B>= 10;  // Out carriage-return disposition
const unsigned char <B>gxsTELOPT_OHT    </B>= 11;  // Output horizontal tabstops
const unsigned char <B>gxsTELOPT_OHTD   </B>= 12;  // Out horizontal tab disposition
const unsigned char <B>gxsTELOPT_OFD    </B>= 13;  // Output formfeed disposition
const unsigned char <B>gxsTELOPT_OVT    </B>= 14;  // Output vertical tabstops
const unsigned char <B>gxsTELOPT_OVTD   </B>= 15;  // Output vertical tab disposition
const unsigned char <B>gxsTELOPT_OLD    </B>= 16;  // Output linefeed disposition
const unsigned char <B>gxsTELOPT_EXT    </B>= 17;  // Extended ascii character set
const unsigned char <B>gxsTELOPT_LOGO   </B>= 18;  // Logout
const unsigned char <B>gxsTELOPT_BYTE   </B>= 19;  // Byte macro
const unsigned char <B>gxsTELOPT_DATA   </B>= 20;  // Data entry terminal
const unsigned char <B>gxsTELOPT_SUP    </B>= 21;  // supdup protocol
const unsigned char <B>gxsTELOPT_SUPO   </B>= 22;  // supdup output
const unsigned char <B>gxsTELOPT_SNDL   </B>= 23;  // Send location
const unsigned char <B>gxsTELOPT_TERM   </B>= 24;  // Terminal type
const unsigned char <B>gxsTELOPT_EOR    </B>= 25;  // End of record
const unsigned char <B>gxsTELOPT_TACACS </B>= 26;  // Tacacs user identification
const unsigned char <B>gxsTELOPT_OM     </B>= 27;  // Output marking
const unsigned char <B>gxsTELOPT_TLN    </B>= 28;  // Terminal location number
const unsigned char <B>gxsTELOPT_3270   </B>= 29;  // Telnet 3270 regime
const unsigned char <B>gxsTELOPT_X3     </B>= 30;  // X.3 PAD
const unsigned char <B>gxsTELOPT_NAWS   </B>= 31;  // Negotiate about window size
const unsigned char <B>gxsTELOPT_TS     </B>= 32;  // Terminal speed
const unsigned char <B>gxsTELOPT_RFC    </B>= 33;  // Remote flow control
const unsigned char <B>gxsTELOPT_LINE   </B>= 34;  // Linemode
const unsigned char <B>gxsTELOPT_XDL    </B>= 35;  // X display location
const unsigned char <B>gxsTELOPT_ENVIR  </B>= 36;  // Telnet environment option
const unsigned char <B>gxsTELOPT_AUTH   </B>= 37;  // Telnet authentication option
const unsigned char <B>gxsTELOPT_NENVIR </B>= 39;  // Telnet environment option
const unsigned char <B>gxsTELOPT_EXTOP  </B>= 255; // Extended-options-list</PRE>
<P><HR></P>
<P><!-- New Section --><A NAME="Enumerations"><B><FONT SIZE=4>Enumerations</A></B></FONT> </P>
<PRE>enum <A NAME="gxsTelnetTermTypes">gxsTelnetTermTypes</A> { // Terminal types
  <B>gxsTEL_NVT_TERM</B>,    // NVT - Network Virtual Terminal
  <B>gxsTEL_VT100F_TERM</B>, // Filtered VT100/ANSI terminal emulation
                      // <B>NOTE</B>: This implementation will only 
                      // filter-out VT100 and ANSI escape 
                      // sequences. This terminal type should  
                      // only be used by embedded telnet clients 
                      // that do not support VT100/ANSI emulations 
                      // but must talk to servers that will not 
                      // support other emulations.
  <B>gxsTEL_ENV_TERM</B>     // Use term type set in environment space
};

enum <A NAME="gxsTelnetState">gxsTelnetState</A> { // Telnet transition state enumeration
  <B>telnet_data</B>,   // Telnet data byte
  <B>telnet_code</B>,   // Telnet code
  <B>telnet_option</B>  // Telnet option
};</PRE>
<P><HR></P>
<P><!-- New Section --><A NAME="Functions"><B><FONT SIZE=4>Functions</A></B></FONT> </P>
<P><A HREF="#gxsTelnetClient">gxsTelnetClient::gxsTelnetClient()</A><BR>
<A HREF="#gxsTelnetClientDestructor">gxsTelnetClient::~gxsTelnetClient()</A><BR>
<A HREF="#ConnectClient">gxsTelnetClient::ConnectClient()</A><BR>
<A HREF="#GetChar">gxsTelnetClient::GetChar()</A><BR>
<A HREF="#GetTermType">gxsTelnetClient::GetTermType()</A><BR>
<A HREF="#OutputCharWaiting">gxsTelnetClient::OutputCharWaiting()</A><BR>
<A HREF="#ReadTelnetData">gxsTelnetClient::ReadTelnetData()</A><BR>
<A HREF="#RecvString">gxsTelnetClient::RecvString()</A><BR>
<A HREF="#SendString">gxsTelnetClient::SendString()</A><BR>
<A HREF="#SetTermType">gxsTelnetClient::SetTermType()</A><BR>
<A HREF="#SetTimeOut">gxsTelnetClient::SetTimeOut()</A><BR>
<A HREF="#WaitForReply">gxsTelnetClient::WaitForReply()</A></P>
<P><BR>
<A NAME="gxsTelnetClient"><B><FONT COLOR="#000080">gxsTelnetClient::gxsTelnetClient()</A></B></FONT>&nbsp;-&nbsp;Default class constructor. </P>
<B><FONT COLOR="#000080"><P><A NAME="gxsTelnetClientDestructor">gxsTelnetClient::~gxsTelnetClient()</A></B></FONT>&nbsp;-&nbsp;Class destructor.</P>
<B><FONT COLOR="#000080"><P><A NAME="ConnectClient">gxSocketError gxsTelnetClient::ConnectClient(const char *host, int port = gxSOCKET_TELNET_PORT)</A></B></FONT>&nbsp;- Public member function used to connect a telnet client to a server. Returns zero if no errors occur.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetChar">int gxsTelnetClient::GetChar(unsigned char &amp;c)</A></B></FONT>&nbsp;-&nbsp;Public member function used to extract a single character from the telnet input stream if a character is waiting to be read. Passes back the character in the "c" variable. Returns true if a character is waiting to be read or false if no characters are waiting.</P>
<B><FONT COLOR="#000080"><P><A NAME="GetTermType">char *gxsTelnetClient::GetTermType()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns the current terminal type name.</P>
<B><FONT COLOR="#000080"><P><A NAME="OutputCharWaiting">int gxsTelnetClient::OutputCharWaiting()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns true if any characters are waiting to be read.</P>
<B><FONT COLOR="#000080"><P><A NAME="ReadTelnetData">gxSocketError gxsTelnetClient::ReadTelnetData(unsigned char data)</A></B></FONT>&nbsp;-&nbsp;Public member function used to read a single character from the telnet input stream and interpret any telnet command sequences. Returns zero if no errors occur.</P>
<B><FONT COLOR="#000080"><P><A NAME="RecvString">gxSocketError gxsTelnetClient::RecvString(char *buf, int bytes, const char *str)</A></B></FONT>&nbsp;-&nbsp;Public blocking receive function used to read a string from a telnet server following a connect or send call. If the specified string is not received within the preset timeout period this function will return a non-zero value to indicate an error. Returns zero if no errors occur. The calling function must allocate a buffer large enough to hold the telnet reply. If the number of bytes received exceed the number of bytes allocated for the "buf" variable this function will return a buffer overflow.</P>
<B><FONT COLOR="#000080"><P><A NAME="SendString">gxSocketError gxsTelnetClient::SendString(const char *buf, int bytes)</A></B></FONT>&nbsp;-&nbsp;Public blocking write function used to send a string to a telnet server. Returns zero if no errors occur. </P>
<B><FONT COLOR="#000080"><P><A NAME="SetTermType">void gxsTelnetClient::SetTermType(gxsTelnetTermTypes ttype = gxsTEL_NVT_TERM)</A></B></FONT>&nbsp;-&nbsp;Public member function used to set the terminal type for this client session.</P>
<B><FONT COLOR="#000080"><P><A NAME="SetTermType_overload_1">void gxsTelnetClient::SetTermType(const char *s)</A></B></FONT>&nbsp;-&nbsp;Public member function used to set a custom terminal type for this client session.</P>
<B><FONT COLOR="#000080"><P><A NAME="SetTimeOut">void gxsTelnetClient::SetTimeOut(int seconds, int useconds)</A></B></FONT>&nbsp;-&nbsp;Public member function used to set telnet timeout values for this client session.</P>
<B><FONT COLOR="#000080"><P><A NAME="WaitForReply">int gxsTelnetClient::WaitForReply()</A></B></FONT>&nbsp;-&nbsp;Public member function that returns false if a reply time is longer then the timeout values.</P>
<P><HR></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 BORDERCOLOR="#000000">
<TR><TD VALIGN="MIDDLE">
<P ALIGN="CENTER"><B>End Of Document</B></TD>
</TR>
</TABLE>
</CENTER></P>

<P>&nbsp;</P>

</BODY>
</HTML>
